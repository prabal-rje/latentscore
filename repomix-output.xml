This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  app/
    __init__.py
    __main__.py
    app.py
    branding.py
    computation.py
    diagnostics_tui.py
    logging_utils.py
    loop.py
    menubar.py
    parent_watch.py
    textual_app_runner.py
    textual_app.py
    textual_serve_runner.py
    tui.py
    webview_app.py
tests/
  conftest.py
  test_app.py
  test_diagnostics_tui.py
  test_init.py
  test_logging_utils.py
  test_menubar.py
  test_parent_watch.py
  test_textual_runners.py
  test_tui.py
  test_webview_app.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/test_webview_app.py">
from app.webview_app import _copy_hint_script


def test_copy_hint_script_includes_message() -> None:
    message = "Use Ctrl + c if you wish to copy."
    script = _copy_hint_script(message)

    assert message in script
    assert "diagnostics-copy-hint" in script
</file>

<file path="src/app/__main__.py">
from .app import main
from .loop import run

if __name__ == "__main__":
    run(main())
</file>

<file path="src/app/app.py">
from __future__ import annotations

from typing import Iterable

from dependency_injector import containers, providers

from .computation import mean_of


class Container(containers.DeclarativeContainer):
    mean = providers.Callable(mean_of)


async def demo_run(values: Iterable[float] | None = None) -> float:
    container = Container()
    sample = values if values is not None else (1.0, 2.0, 3.0)
    return await container.mean(sample)


async def main() -> None:
    result = await demo_run()
    print(f"Sample mean: {result:.2f}")
</file>

<file path="src/app/branding.py">
from __future__ import annotations


def _slugify(name: str) -> str:
    cleaned: list[str] = []
    last_was_sep = True
    for ch in name.strip().lower():
        if ch.isalnum():
            cleaned.append(ch)
            last_was_sep = False
            continue
        if last_was_sep:
            continue
        cleaned.append("-")
        last_was_sep = True
    return "".join(cleaned).strip("-")


def _env_prefix(slug: str) -> str:
    cleaned: list[str] = []
    last_was_sep = True
    for ch in slug:
        if ch.isalnum():
            cleaned.append(ch.upper())
            last_was_sep = False
            continue
        if last_was_sep:
            continue
        cleaned.append("_")
        last_was_sep = True
    return "".join(cleaned).strip("_")


APP_NAME = "Sample App"
APP_SLUG = _slugify(APP_NAME) or "sample-app"
APP_ENV_PREFIX = _env_prefix(APP_SLUG) or "SAMPLE_APP"
</file>

<file path="src/app/computation.py">
from __future__ import annotations

from typing import Callable, Iterable

Number = float | int


async def mean_of(
    values: Iterable[Number],
    transform: Callable[[Number], Number] | None = None,
) -> float:
    numbers = list(values)
    if not numbers:
        return 0.0

    mapper: Callable[[Number], Number] = transform or (lambda x: x)
    mapped = list(map(mapper, numbers))
    return sum(mapped) / len(mapped)
</file>

<file path="src/app/parent_watch.py">
from __future__ import annotations

import os
import signal
import threading
import time
from dataclasses import dataclass
from typing import Mapping

from .branding import APP_ENV_PREFIX

PARENT_FD_ENV = f"{APP_ENV_PREFIX}_PARENT_FD"
PARENT_PID_ENV = f"{APP_ENV_PREFIX}_PARENT_PID"


@dataclass(frozen=True)
class ParentWatchConfig:
    fd: int | None
    pid: int | None


def create_parent_watch_pipe() -> tuple[int, int]:
    return os.pipe()


def parse_parent_watch_env(env: Mapping[str, str] | None = None) -> ParentWatchConfig:
    source = os.environ if env is None else env
    fd = _coerce_fd(source.get(PARENT_FD_ENV))
    pid = _coerce_pid(source.get(PARENT_PID_ENV))
    return ParentWatchConfig(fd=fd, pid=pid)


_started_fd = False
_started_pid = False


def start_parent_watchdog_from_env(
    env: Mapping[str, str] | None = None,
    *,
    interval: float = 1.0,
) -> bool:
    config = parse_parent_watch_env(env)
    return start_parent_watchdog(config, interval=interval)


def start_parent_watchdog(config: ParentWatchConfig, *, interval: float = 1.0) -> bool:
    started = False
    global _started_fd, _started_pid
    if config.fd is not None and not _started_fd:
        thread = threading.Thread(target=_watch_fd, args=(config.fd,), daemon=True)
        thread.start()
        _started_fd = True
        started = True
    if config.pid is not None and not _started_pid:
        thread = threading.Thread(target=_watch_pid, args=(config.pid, interval), daemon=True)
        thread.start()
        _started_pid = True
        started = True
    return started


def _coerce_fd(value: str | None) -> int | None:
    if value is None:
        return None
    try:
        fd = int(value)
    except ValueError:
        return None
    if fd < 0:
        return None
    try:
        os.fstat(fd)
    except OSError:
        return None
    return fd


def _coerce_pid(value: str | None) -> int | None:
    if value is None:
        return None
    try:
        pid = int(value)
    except ValueError:
        return None
    if pid <= 1:
        return None
    return pid


def _watch_fd(fd: int) -> None:
    while True:
        try:
            data = os.read(fd, 1024)
        except OSError:
            break
        if not data:
            break
    _terminate_self()


def _watch_pid(pid: int, interval: float) -> None:
    interval = interval if interval > 0 else 1.0
    while True:
        if not _pid_alive(pid):
            _terminate_self()
            return
        time.sleep(interval)


def _pid_alive(pid: int) -> bool:
    if pid <= 1:
        return False
    try:
        os.kill(pid, 0)
    except ProcessLookupError:
        return False
    except PermissionError:
        return True
    return True


def _terminate_self() -> None:
    try:
        os.kill(os.getpid(), signal.SIGTERM)
    except Exception:
        os._exit(0)
    time.sleep(1.0)
    os._exit(0)
</file>

<file path="src/app/textual_app.py">
from __future__ import annotations

import logging
from typing import ClassVar

from textual import events
from textual.app import App, ComposeResult
from textual.binding import BindingType
from textual.containers import Vertical
from textual.widgets import Footer, Header, Static

from .branding import APP_NAME
from .logging_utils import QUIT_SIGNAL_FILENAME, log_path, setup_file_logger

LOGGER_NAME = f"{__package__ or 'app'}.textual"


class NonTallHeader(Header):
    """Header that keeps the tall flag disabled on click."""

    def _on_click(self) -> None:
        """Call through for now; this inexplicably avoids the titlebar glitch."""
        # We don't know why this variant behaves correctly, but it does in practice.
        super()._on_click()

    def watch_tall(self, tall: bool) -> None:
        """Keep the header in short mode even if tall gets toggled."""
        self.set_class(False, "-tall")


class SampleApp(App[None]):
    """Minimal Textual app placeholder for the tracer bullet."""

    TITLE = APP_NAME
    _inherit_bindings = False
    BINDINGS: ClassVar[list[BindingType]] = []

    def on_mount(self) -> None:
        log_file = setup_file_logger(LOGGER_NAME, "textual-ui.log")
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("%s mounted (log check).", self.__class__.__name__)
        logger.info("%s logs at %s", APP_NAME, log_file)

    def on_ready(self) -> None:
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("%s ready (log check).", self.__class__.__name__)

    def on_click(self, event: events.Click) -> None:
        if isinstance(event.control, NonTallHeader):
            logger = logging.getLogger(LOGGER_NAME)
            logger.info("Header clicked (log check).")
            event.control.remove_class("-tall")

    async def action_quit(self) -> None:
        signal_path = log_path(QUIT_SIGNAL_FILENAME)
        signal_path.write_text("quit", encoding="utf-8")
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("Quit requested; wrote %s", signal_path)
        self.exit()

    def compose(self) -> ComposeResult:
        yield NonTallHeader(show_clock=False)
        with Vertical():
            yield Static(f"{APP_NAME} is running via the menubar app.", id="body")
            yield Static("Use the menubar item to open this UI.", id="hint")
            yield Static(f"Logs: {log_path('textual-ui.log')}", id="logs")
        yield Footer()


APP_SPEC = f"{__name__}:{SampleApp.__name__}"


def run() -> None:
    setup_file_logger(LOGGER_NAME, "textual-ui.log")
    logging.getLogger(LOGGER_NAME).info(
        "Launching %s (log check).",
        SampleApp.__name__,
    )
    SampleApp().run()


if __name__ == "__main__":
    run()
</file>

<file path="src/app/tui.py">
from __future__ import annotations

from textual.app import App, ComposeResult
from textual.widgets import Static

from .loop import install_uvloop_policy


class HelloWorldApp(App[None]):
    """Minimal Textual application that shows a hello world message."""

    CSS = """
    Screen {
        align: center middle;
    }

    #greeting {
        content-align: center middle;
    }
    """

    def compose(self) -> ComposeResult:
        yield Static("Hello world!", id="greeting")


def run_tui() -> None:
    """Install uvloop and run the hello world Textual app."""
    install_uvloop_policy()
    HelloWorldApp().run()


if __name__ == "__main__":
    run_tui()
</file>

<file path="tests/conftest.py">
import sys
from pathlib import Path

# Ensure the src package directory is importable when running tests without installation.
PROJECT_ROOT = Path(__file__).resolve().parents[1]
SRC_DIR = PROJECT_ROOT / "src"
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))
</file>

<file path="tests/test_diagnostics_tui.py">
import importlib
from types import SimpleNamespace

from app.diagnostics_tui import DiagnosticsApp


def test_copy_text_to_clipboard_uses_pyperclip(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)

    calls: dict[str, str] = {}

    def fake_copy(text: str) -> None:
        calls["text"] = text

    fake_module = SimpleNamespace(copy=fake_copy)

    def fake_import(name: str) -> object:
        assert name == "pyperclip"
        return fake_module

    monkeypatch.setattr(importlib, "import_module", fake_import)

    assert app._copy_text_to_clipboard("hello") is True
    assert calls["text"] == "hello"


def test_copy_text_to_clipboard_empty_returns_false(tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)

    assert app._copy_text_to_clipboard("") is False


def test_copy_text_to_clipboard_requires_pyperclip(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)

    def fake_import(_name: str) -> object:
        raise ImportError("missing")

    monkeypatch.setattr(importlib, "import_module", fake_import)

    assert app._copy_text_to_clipboard("hello") is False


def test_action_copy_selection_notifies_on_empty(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)
    messages: list[str] = []

    def fake_notify(message: str, *_args, **_kwargs) -> None:
        messages.append(message)

    monkeypatch.setattr(app, "notify", fake_notify)
    monkeypatch.setattr(app, "_selected_text", lambda: None)

    app.action_copy_selection()

    assert messages == ["No text selected to copy."]


def test_action_copy_selection_notifies_on_success(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)
    messages: list[str] = []

    def fake_notify(message: str, *_args, **_kwargs) -> None:
        messages.append(message)

    monkeypatch.setattr(app, "notify", fake_notify)
    monkeypatch.setattr(app, "_selected_text", lambda: "hello")
    monkeypatch.setattr(app, "_copy_text_to_clipboard", lambda _text: True)

    app.action_copy_selection()

    assert messages == ["Copied to clipboard."]


def test_action_copy_selection_notifies_on_failure(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)
    messages: list[str] = []

    def fake_notify(message: str, *_args, **_kwargs) -> None:
        messages.append(message)

    monkeypatch.setattr(app, "notify", fake_notify)
    monkeypatch.setattr(app, "_selected_text", lambda: "hello")
    monkeypatch.setattr(app, "_copy_text_to_clipboard", lambda _text: False)

    app.action_copy_selection()

    assert messages == ["Clipboard copy failed; ensure pyperclip is installed."]


def test_action_copy_hint_notifies(monkeypatch, tmp_path) -> None:
    app = DiagnosticsApp(tmp_path)
    messages: list[str] = []

    def fake_notify(message: str, *_args, **_kwargs) -> None:
        messages.append(message)

    monkeypatch.setattr(app, "notify", fake_notify)

    app.action_copy_hint()

    assert messages == ["Use Ctrl + c if you wish to copy."]
</file>

<file path="tests/test_parent_watch.py">
import os

from app.parent_watch import PARENT_FD_ENV, PARENT_PID_ENV, parse_parent_watch_env


def test_parse_parent_watch_env_reads_fd_and_pid() -> None:
    read_fd, write_fd = os.pipe()
    try:
        env = {
            PARENT_FD_ENV: str(read_fd),
            PARENT_PID_ENV: str(os.getpid()),
        }
        config = parse_parent_watch_env(env)
        assert config.fd == read_fd
        assert config.pid == os.getpid()
    finally:
        os.close(read_fd)
        os.close(write_fd)


def test_parse_parent_watch_env_ignores_invalid_values() -> None:
    env = {
        PARENT_FD_ENV: "not-a-fd",
        PARENT_PID_ENV: "-1",
    }
    config = parse_parent_watch_env(env)
    assert config.fd is None
    assert config.pid is None
</file>

<file path="src/app/__init__.py">
from __future__ import annotations

from importlib import import_module
from typing import TYPE_CHECKING

from .app import demo_run, main
from .loop import install_uvloop_policy, run
from .tui import HelloWorldApp, run_tui

if TYPE_CHECKING:
    from .menubar import MenuBarApp, run_menu_bar

__all__ = [
    "demo_run",
    "HelloWorldApp",
    "install_uvloop_policy",
    "main",
    "MenuBarApp",
    "run",
    "run_menu_bar",
    "run_tui",
]


def __getattr__(name: str) -> object:
    if name in {"MenuBarApp", "run_menu_bar"}:
        module = import_module(".menubar", __name__)
        return getattr(module, name)
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


def __dir__() -> list[str]:
    return sorted(__all__)
</file>

<file path="src/app/logging_utils.py">
from __future__ import annotations

import logging
import os
import platform
from pathlib import Path

from .branding import APP_ENV_PREFIX, APP_NAME, APP_SLUG

LOG_DIR_ENV = f"{APP_ENV_PREFIX}_LOG_DIR"
LOG_DIR_NAME = APP_NAME
QUIT_SIGNAL_FILENAME = "textual-ui.quit"
DIAGNOSTICS_QUIT_SIGNAL_FILENAME = "diagnostics-ui.quit"


def default_log_dir() -> Path:
    env_dir = os.environ.get(LOG_DIR_ENV)
    if env_dir:
        return Path(env_dir).expanduser()
    if platform.system() == "Darwin":
        return Path.home() / "Library" / "Logs" / LOG_DIR_NAME
    return Path.home() / f".{APP_SLUG}" / "logs"


def log_path(filename: str, app_support_dir: str | None = None) -> Path:
    base_dir = Path(app_support_dir) if app_support_dir else default_log_dir()
    return base_dir / filename


def setup_file_logger(
    name: str,
    filename: str,
    *,
    level: int = logging.INFO,
    app_support_dir: str | None = None,
) -> Path:
    logger = logging.getLogger(name)
    path = log_path(filename, app_support_dir)
    path.parent.mkdir(parents=True, exist_ok=True)
    if logger.handlers:
        return path
    logger.setLevel(level)
    handler = logging.FileHandler(path)
    handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s"))
    logger.addHandler(handler)
    return path
</file>

<file path="src/app/loop.py">
from __future__ import annotations

import asyncio
import sys
from typing import Any, Coroutine, TypeVar

uvloop: Any | None
if sys.platform.startswith("win"):
    uvloop = None
else:
    try:
        import uvloop as _uvloop
    except ImportError:
        uvloop = None
    else:
        uvloop = _uvloop

T = TypeVar("T")


def install_uvloop_policy() -> None:
    """Install uvloop as the default event loop policy when available."""
    if uvloop is None:
        return
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())


def run(coro: Coroutine[object, object, T]) -> T:
    """Run a coroutine with uvloop installed."""
    install_uvloop_policy()
    return asyncio.run(coro)
</file>

<file path="src/app/textual_serve_runner.py">
from __future__ import annotations

import argparse
import shlex
import sys

from textual_serve.server import Server

from . import textual_app_runner
from .parent_watch import start_parent_watchdog_from_env


def build_command(app_spec: str) -> str:
    args = [sys.executable, "-m", textual_app_runner.__name__, "--app", app_spec]
    return shlex.join(args)


def main(argv: list[str] | None = None) -> int:
    start_parent_watchdog_from_env()
    parser = argparse.ArgumentParser(description="Serve a Textual app over the web.")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=8000)
    parser.add_argument("--app", required=True, help="App spec like package.module:AppClass")
    args = parser.parse_args(argv)

    command = build_command(args.app)
    print(f"textual-serve starting for {args.app} on {args.host}:{args.port}")
    Server(command=command, host=args.host, port=args.port).serve()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="src/app/webview_app.py">
from __future__ import annotations

import argparse
import importlib
import json
import platform
from importlib.util import find_spec
from typing import Any

from .branding import APP_NAME
from .parent_watch import start_parent_watchdog_from_env


def main(argv: list[str] | None = None) -> int:
    start_parent_watchdog_from_env()
    parser = argparse.ArgumentParser(description="Open a webview window.")
    parser.add_argument("--url", required=True)
    parser.add_argument("--title", default=APP_NAME)
    parser.add_argument("--width", type=int, default=1000)
    parser.add_argument("--height", type=int, default=700)
    parser.add_argument(
        "--screen-fraction",
        type=float,
        default=None,
        help="Size the window to a fraction of the primary screen (0 < fraction <= 1).",
    )
    parser.add_argument(
        "--resizable",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Allow the window to be resized.",
    )
    parser.add_argument(
        "--frameless",
        default=False,
        action=argparse.BooleanOptionalAction,
        help="Render the window without the native frame.",
    )
    parser.add_argument(
        "--easy-drag",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Enable easy drag mode for frameless windows.",
    )
    args = parser.parse_args(argv)

    webview = importlib.import_module("webview")
    menu_module = importlib.import_module("webview.menu")
    menu_cls = getattr(menu_module, "Menu", None)
    menu_action_cls = getattr(menu_module, "MenuAction", None)
    assert menu_cls is not None
    assert menu_action_cls is not None

    if platform.system() == "Darwin":
        _set_app_name(args.title)

    def show_yolo_dialog() -> None:
        windows = getattr(webview, "windows", None)
        if not windows:
            return
        window = windows[0]
        evaluate_js = getattr(window, "evaluate_js", None)
        assert callable(evaluate_js)
        evaluate_js("alert('YOLO Test')")

    menu = [menu_cls("YOLO Test", [menu_action_cls("Show dialog", show_yolo_dialog)])]
    width, height = _resolve_window_size(args, webview)

    create_window = getattr(webview, "create_window", None)
    assert callable(create_window)
    window = create_window(
        args.title,
        args.url,
        width=width,
        height=height,
        resizable=args.resizable,
        frameless=args.frameless,
        easy_drag=args.easy_drag,
        menu=menu,
    )
    if window is None:
        return 1
    _install_copy_hint(window, "Use Ctrl + c if you wish to copy.")
    start = getattr(webview, "start", None)
    assert callable(start)
    start()
    return 0


def _resolve_window_size(args: argparse.Namespace, webview_module: Any) -> tuple[int, int]:
    width = args.width
    height = args.height
    fraction = args.screen_fraction
    if fraction is None:
        return width, height
    if not 0 < fraction <= 1:
        raise SystemExit("--screen-fraction must be between 0 and 1")
    screens = getattr(webview_module, "screens", None)
    if not screens:
        return width, height
    screen = screens[0]
    screen_width = getattr(screen, "width", None)
    screen_height = getattr(screen, "height", None)
    if not isinstance(screen_width, int) or not isinstance(screen_height, int):
        return width, height
    return max(1, int(screen_width * fraction)), max(1, int(screen_height * fraction))


def _install_copy_hint(window: Any, message: str) -> None:
    events = getattr(window, "events", None)
    if events is None:
        return
    loaded = getattr(events, "loaded", None)
    if loaded is None:
        return

    def _on_loaded(window: Any) -> None:
        evaluate_js = getattr(window, "evaluate_js", None)
        if not callable(evaluate_js):
            return
        evaluate_js(_copy_hint_script(message))

    loaded += _on_loaded
    if loaded.is_set():
        _on_loaded(window)


def _copy_hint_script(message: str) -> str:
    payload = json.dumps(message)
    return f"""
(() => {{
  if (window.__diagnosticsCopyHintInstalled) return;
  window.__diagnosticsCopyHintInstalled = true;
  const message = {payload};
  const styleId = "diagnostics-copy-hint-style";
  if (!document.getElementById(styleId)) {{
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
      .diagnostics-copy-hint {{
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(24, 24, 24, 0.9);
        color: #f5f5f5;
        padding: 8px 14px;
        border-radius: 8px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        font-size: 13px;
        letter-spacing: 0.2px;
        opacity: 0;
        transition: opacity 160ms ease-in-out;
        z-index: 2147483647;
        pointer-events: none;
      }}
      .diagnostics-copy-hint.show {{
        opacity: 1;
      }}
    `;
    document.head.appendChild(style);
  }}
  const showHint = () => {{
    let node = document.getElementById("diagnostics-copy-hint");
    if (!node) {{
      node = document.createElement("div");
      node.id = "diagnostics-copy-hint";
      node.className = "diagnostics-copy-hint";
      document.body.appendChild(node);
    }}
    node.textContent = message;
    node.classList.add("show");
    if (window.__diagnosticsCopyHintTimer) {{
      clearTimeout(window.__diagnosticsCopyHintTimer);
    }}
    window.__diagnosticsCopyHintTimer = setTimeout(() => {{
      node.classList.remove("show");
    }}, 2000);
  }};
  document.addEventListener("keydown", (event) => {{
    if (!event.metaKey) return;
    const key = (event.key || "").toLowerCase();
    if (key !== "c") return;
    showHint();
  }}, true);
}})();
"""


def _set_app_name(title: str) -> None:
    if find_spec("Foundation") is None or find_spec("webview.platforms.cocoa") is None:
        return

    foundation = importlib.import_module("Foundation")
    cocoa = importlib.import_module("webview.platforms.cocoa")
    ns_process_info = getattr(foundation, "NSProcessInfo", None)
    assert ns_process_info is not None
    process_info = ns_process_info.processInfo()
    set_name = getattr(process_info, "setProcessName_", None)
    assert callable(set_name)
    set_name(title)
    info = getattr(cocoa, "info", None)
    if info is None:
        return
    setter = getattr(info, "__setitem__", None)
    if not callable(setter):
        return
    setter("CFBundleName", title)


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="tests/test_init.py">
import app


def test_menubar_reexports_are_accessible() -> None:
    MenuBarApp = getattr(app, "MenuBarApp")
    run_menu_bar = getattr(app, "run_menu_bar")

    assert MenuBarApp.__name__ == "MenuBarApp"
    assert callable(run_menu_bar)
</file>

<file path="tests/test_logging_utils.py">
import logging

from app.logging_utils import LOG_DIR_ENV, default_log_dir, log_path, setup_file_logger


def test_log_path_uses_env_override(tmp_path, monkeypatch) -> None:
    monkeypatch.setenv(LOG_DIR_ENV, str(tmp_path))
    assert default_log_dir() == tmp_path
    assert log_path("demo.log") == tmp_path / "demo.log"


def test_setup_file_logger_creates_handler(tmp_path, monkeypatch) -> None:
    monkeypatch.setenv(LOG_DIR_ENV, str(tmp_path))
    logger_name = f"app.test.{tmp_path.name}"
    path = setup_file_logger(logger_name, "app.log")
    assert path == tmp_path / "app.log"
    logger = logging.getLogger(logger_name)
    assert any(isinstance(handler, logging.FileHandler) for handler in logger.handlers)
</file>

<file path="tests/test_textual_runners.py">
from app import textual_app, textual_app_runner
from app.textual_app_runner import resolve_app
from app.textual_serve_runner import build_command


def test_resolve_app_from_class() -> None:
    app = resolve_app(textual_app.APP_SPEC)
    assert app.__class__.__name__ == textual_app.SampleApp.__name__


def test_build_command_contains_runner() -> None:
    cmd = build_command(textual_app.APP_SPEC)
    assert textual_app_runner.__name__ in cmd
</file>

<file path="tests/test_tui.py">
import pytest
from textual.widgets import Static

from app.tui import HelloWorldApp


@pytest.mark.asyncio
async def test_hello_world_app_renders_greeting() -> None:
    async with HelloWorldApp().run_test() as pilot:
        greeting = pilot.app.query_one("#greeting", Static)
        rendered = greeting.render()
        assert "Hello world!" in str(rendered)
</file>

<file path="src/app/diagnostics_tui.py">
from __future__ import annotations

import argparse
import subprocess
import sys
from dataclasses import dataclass, field
from pathlib import Path

from textual import events
from textual.app import App, ComposeResult, ScreenStackError
from textual.binding import Binding
from textual.containers import Horizontal, Vertical
from textual.widgets import Footer, Header, Input, Static, TextArea

from .branding import APP_NAME
from .logging_utils import DIAGNOSTICS_QUIT_SIGNAL_FILENAME, LOG_DIR_ENV, default_log_dir
from .loop import install_uvloop_policy


def _empty_lines() -> list[str]:
    return []


@dataclass
class _LogPane:
    title: str
    path: Path
    widget: TextArea
    position: int = 0
    missing_noted: bool = False
    lines: list[str] = field(default_factory=_empty_lines)
    match_index: int = -1
    highlight_line: int | None = None


class _DiagnosticsTextArea(TextArea):
    app: "DiagnosticsApp"

    def action_copy(self) -> None:
        self.app.action_copy_selection()


class DiagnosticsHeader(Header):
    app: "DiagnosticsApp"

    def _on_click(self) -> None:
        return

    def watch_tall(self, tall: bool) -> None:
        self.set_class(tall, "-tall")

    def on_mouse_down(self, event: events.MouseDown) -> None:
        if event.button == 1:
            app = self.app
            assert isinstance(app, DiagnosticsApp)
            app.action_show_help()


class DiagnosticsApp(App[None]):
    """Textual log viewer for diagnostics."""

    _inherit_bindings = False
    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("f", "toggle_follow", "Follow"),
        Binding("ctrl+c", "copy_selection", "Copy", key_display="Ctrl+C", priority=True),
        Binding("r", "reload", "Reload"),
        Binding("/", "focus_search", "Search"),
        Binding("escape", "close_search", "Close Search"),
        Binding("n", "search_next", "Next Match"),
        Binding("N", "search_prev", "Prev Match"),
        Binding("?", "show_help", "Help"),
        Binding("h", "show_help", "Help"),
    ]

    # Minimal CSS for layout only - widget styling done via native SDK
    CSS = """
    Screen {
        layout: vertical;
    }

    #logs {
        height: 1fr;
        border-top: solid $secondary;
    }

    #search-bar {
        display: none;
        height: auto;
        padding: 1;
        background: $surface;
        border-bottom: solid $secondary;
    }

    #search-bar.visible {
        display: block;
    }

    #search-label {
        padding-right: 1;
        padding-top: 1;
        height: 3;
        content-align: center middle;
    }

    #search-input {
        width: 1fr;
        height: auto; /* Let the widget decide its own natural height */
        border: tall $accent;
        background: $surface;
        color: $foreground;
    }

    #help {
        display: none;
        padding: 1;
        background: $panel;
        border: tall $primary;
        dock: bottom;
        layer: overlay;
        width: 60%;
        height: auto;
    }

    #help.visible {
        display: block;
    }

    #size-warning {
        display: none;
        layer: overlay;
        width: 100%;
        height: 100%;
        background: $panel;
        color: $text-muted;
        content-align: center middle;
        border: tall $accent;
    }

    #size-warning.visible {
        display: block;
    }

    .pane {
        width: 1fr;
    }

    .pane-title {
        padding: 0 1;
        background: $surface;
        color: $text-muted;
    }

    TextArea {
        height: 1fr;
    }

    TextArea .text-area--selection {
        background: $accent 40%;
    }
    """

    def __init__(
        self,
        log_dir: Path,
        *,
        max_lines: int = 5000,
        min_viewport_width: int = 110,
        min_viewport_height: int = 28,
    ) -> None:
        super().__init__()
        self._log_dir = log_dir
        self._max_lines = max_lines
        self._min_viewport_width = min_viewport_width
        self._min_viewport_height = min_viewport_height
        self._follow = True
        self._search_query: str | None = None
        self._search_visible = False
        self._active_pane: _LogPane | None = None
        self._panes: list[_LogPane] = []
        self._size_warning = Static(
            "Please re-size window to view properly",
            id="size-warning",
        )
        # Use TextArea for proper text selection and copy support
        self._menubar_log = _DiagnosticsTextArea(id="menubar-log", read_only=True)
        self._ui_log = _DiagnosticsTextArea(id="ui-log", read_only=True)
        self._search_input = Input(
            placeholder="Type search query and press Enter", id="search-input"
        )
        help_text = (
            "Diagnostics viewer\n"
            "  /      search (press Enter to jump)\n"
            "  n/N    next/prev match\n"
            "  f      toggle follow\n"
            "  r      reload logs\n"
            "  Ctrl+C  copy selection\n"
            "  q      quit"
        )
        self._help = Static(help_text, id="help")

    def compose(self) -> ComposeResult:
        yield DiagnosticsHeader(show_clock=False)
        yield self._help
        yield self._size_warning
        with Horizontal(id="search-bar"):
            yield self._search_input
        with Horizontal(id="logs"):
            with Vertical(classes="pane"):
                yield Static("Menubar Server", classes="pane-title")
                yield self._menubar_log
            with Vertical(classes="pane"):
                yield Static("Textual UI", classes="pane-title")
                yield self._ui_log
        yield Footer()

    def on_mount(self) -> None:
        self.notify("Diagnostics viewer mounted (runtime check).", timeout=2.0)
        self._panes = [
            _LogPane(
                "Menubar Server",
                self._log_dir / "menubar-server.log",
                self._menubar_log,
            ),
            _LogPane("Textual UI", self._log_dir / "textual-ui.log", self._ui_log),
        ]
        self._active_pane = self._panes[0]
        self._active_pane.widget.focus()
        self._load_initial()
        self._update_size_warning()
        self.set_interval(0.35, self._poll_files)

    def action_toggle_follow(self) -> None:
        self._follow = not self._follow
        status = "on" if self._follow else "off"
        self.notify(f"Follow {status}", timeout=1.0)
        if self._follow:
            self._scroll_to_end_all()

    def action_reload(self) -> None:
        for pane in self._panes:
            pane.widget.load_text("")
            pane.position = 0
            pane.missing_noted = False
            pane.lines.clear()
            pane.match_index = -1
        self._load_initial()
        self.notify("Reloaded logs", timeout=1.0)

    def _scroll_to_end_all(self) -> None:
        """Scroll all log panes to the end."""
        for pane in self._panes:
            pane.widget.scroll_end(animate=False)

    def action_focus_search(self) -> None:
        self._search_visible = True
        self.query_one("#search-bar").add_class("visible")
        self._search_input.value = self._search_query or ""
        self._search_input.focus()

    def action_close_search(self) -> None:
        if not self._search_visible:
            return
        self._search_visible = False
        self.query_one("#search-bar").remove_class("visible")
        if self._active_pane:
            self._active_pane.widget.focus()

    def action_search_next(self) -> None:
        self._jump_match(1)

    def action_search_prev(self) -> None:
        self._jump_match(-1)

    def action_show_help(self) -> None:
        help_widget = self.query_one("#help")
        if "visible" in help_widget.classes:
            help_widget.remove_class("visible")
        else:
            help_widget.add_class("visible")

    def action_copy_selection(self) -> None:
        selected_text = self._selected_text()
        if not selected_text:
            self.notify("No text selected to copy.", timeout=2.0)
            return
        if self._copy_text_to_clipboard(selected_text):
            self.notify("Copied to clipboard.", timeout=2.0)
        else:
            self.notify("Clipboard copy failed; ensure pyperclip is installed.", timeout=2.0)

    def action_copy_hint(self) -> None:
        self.notify("Use Ctrl + c if you wish to copy.", timeout=2.0)

    def on_key(self, event: events.Key) -> None:
        if event.key in ("meta+c", "super+c"):
            self.action_copy_hint()
            event.stop()

    def _selected_text(self) -> str | None:
        target = self.focused
        if isinstance(target, (TextArea, Input)):
            if target.selected_text:
                return target.selected_text
        try:
            screen = self.screen
        except ScreenStackError:
            screen = None
        if screen is not None:
            screen_selection = screen.get_selected_text()
            if screen_selection:
                return screen_selection
        if self._active_pane is None:
            return None
        return self._active_pane.widget.selected_text or None

    def _copy_text_to_clipboard(self, text: str) -> bool:
        if not text:
            return False
        if not self._copy_with_pyperclip(text):
            return False
        try:
            self.copy_to_clipboard(text)
        except Exception:
            pass
        return True

    def _copy_with_pyperclip(self, text: str) -> bool:
        try:
            import importlib

            pyperclip = importlib.import_module("pyperclip")
        except Exception:
            return False
        try:
            pyperclip.copy(text)
            return True
        except Exception:
            return False

    def _copy_with_os_command(self, text: str) -> bool:
        if sys.platform != "darwin":
            return False
        try:
            result = subprocess.run(
                ["pbcopy"],
                input=text.encode("utf-8"),
                check=False,
            )
        except Exception:
            return False
        return result.returncode == 0

    def on_focus(self, event: events.Focus) -> None:
        control = event.control
        if isinstance(control, TextArea):
            pane = self._pane_for_widget(control)
            if pane is not None:
                self._active_pane = pane

    def on_click(self, event: events.Click) -> None:
        if isinstance(event.control, Header):
            event.control.remove_class("-tall")

    def on_resize(self, event: events.Resize) -> None:
        self._update_size_warning(event.size.width, event.size.height)

    def on_input_submitted(self, event: Input.Submitted) -> None:
        if event.input is not self._search_input:
            return
        query = event.value.strip()
        if not query:
            self._search_query = None
            if self._active_pane:
                self._active_pane.highlight_line = None
            self.notify("Search cleared", timeout=1.0)
            self.action_close_search()
            return
        self._follow = False
        self._search_query = query
        self._jump_match(1, reset=True)
        self.action_close_search()

    async def action_quit(self) -> None:
        signal_path = self._log_dir / DIAGNOSTICS_QUIT_SIGNAL_FILENAME
        signal_path.write_text("quit", encoding="utf-8")
        self.exit()

    def _load_initial(self) -> None:
        for pane in self._panes:
            if not pane.path.exists():
                if not pane.missing_noted:
                    pane.lines.append(f"{pane.title} log not found yet at {pane.path}")
                    self._update_pane_text(pane)
                    pane.missing_noted = True
                continue
            text = pane.path.read_text(encoding="utf-8", errors="replace")
            lines = text.splitlines()
            tail = lines[-200:] if len(lines) > 200 else lines
            pane.lines.extend(tail)
            self._update_pane_text(pane)
            pane.position = pane.path.stat().st_size
        if self._follow:
            self._scroll_to_end_all()

    def _poll_files(self) -> None:
        any_updated = False
        for pane in self._panes:
            if not pane.path.exists():
                if not pane.missing_noted:
                    pane.lines.append(f"{pane.title} log not found yet at {pane.path}")
                    self._update_pane_text(pane)
                    pane.missing_noted = True
                continue
            try:
                size = pane.path.stat().st_size
            except OSError:
                continue
            if size < pane.position:
                pane.lines.clear()
                pane.match_index = -1
                pane.lines.append(f"{pane.title} log rotated")
                pane.position = 0
                self._update_pane_text(pane)
                any_updated = True
            with pane.path.open("r", encoding="utf-8", errors="replace") as handle:
                handle.seek(pane.position)
                chunk = handle.read()
                pane.position = handle.tell()
            if not chunk:
                continue
            new_lines = chunk.splitlines()
            pane.lines.extend(new_lines)
            # Trim to max_lines
            if len(pane.lines) > self._max_lines:
                pane.lines = pane.lines[-self._max_lines :]
            self._update_pane_text(pane)
            any_updated = True
        if any_updated and self._follow:
            self._scroll_to_end_all()

    def _update_pane_text(self, pane: _LogPane) -> None:
        """Update the TextArea content with all lines."""
        pane.widget.load_text("\n".join(pane.lines))

    def _update_size_warning(self, width: int | None = None, height: int | None = None) -> None:
        size = self.size
        resolved_width = width if width is not None else size.width
        resolved_height = height if height is not None else size.height
        too_small = (
            resolved_width < self._min_viewport_width or resolved_height < self._min_viewport_height
        )
        self._size_warning.set_class(too_small, "visible")

    def _pane_for_widget(self, widget: TextArea) -> _LogPane | None:
        for pane in self._panes:
            if pane.widget is widget:
                return pane
        return None

    def _jump_match(self, direction: int, *, reset: bool = False) -> None:
        if not self._search_query:
            self.notify("No active search", timeout=1.0)
            return
        pane = self._active_pane
        if pane is None:
            return
        matches = self._search_matches(pane, self._search_query)
        if not matches:
            self.notify(f"No matches for {self._search_query!r}", timeout=1.0)
            pane.match_index = -1
            pane.highlight_line = None
            return
        if reset or pane.match_index < 0:
            pane.match_index = 0
        else:
            pane.match_index = (pane.match_index + direction) % len(matches)
        line_index = matches[pane.match_index]
        pane.highlight_line = line_index
        # Move cursor to the matching line and select it
        pane.widget.focus()
        pane.widget.move_cursor((line_index, 0))
        pane.widget.select_line(line_index)
        self.notify(
            f"{pane.title}: match {pane.match_index + 1}/{len(matches)}",
            timeout=1.0,
        )

    def _search_matches(self, pane: _LogPane, query: str) -> list[int]:
        target = query.lower()
        return [idx for idx, line in enumerate(pane.lines) if target in line.lower()]


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=f"{APP_NAME} diagnostics viewer")
    parser.add_argument(
        "--log-dir",
        type=Path,
        default=default_log_dir(),
        help=f"Log directory (default: ${LOG_DIR_ENV} or platform default)",
    )
    return parser.parse_args()


def build_app(log_dir: Path | None = None) -> DiagnosticsApp:
    install_uvloop_policy()
    return DiagnosticsApp(log_dir or default_log_dir())


APP_SPEC = f"{__name__}:{build_app.__name__}"


def run() -> None:
    args = _parse_args()
    build_app(args.log_dir).run()


if __name__ == "__main__":
    run()
</file>

<file path="src/app/menubar.py">
from __future__ import annotations

import atexit
import importlib
import importlib.util
import os
import platform
import signal
import socket
import subprocess
import sys
import time
import webbrowser
from pathlib import Path
from types import SimpleNamespace
from typing import IO, Any, Optional

import AppKit  # type: ignore[import]
import rumps  # type: ignore[import]
from rumps import utils as rumps_utils  # type: ignore[import]

from . import webview_app
from .branding import APP_NAME
from .diagnostics_tui import APP_SPEC as DIAGNOSTICS_APP_SPEC
from .logging_utils import (
    DIAGNOSTICS_QUIT_SIGNAL_FILENAME,
    LOG_DIR_ENV,
    QUIT_SIGNAL_FILENAME,
    default_log_dir,
    log_path,
)
from .parent_watch import PARENT_FD_ENV, PARENT_PID_ENV, create_parent_watch_pipe
from .textual_app import APP_SPEC as TEXTUAL_APP_SPEC

NSApplication: Any = getattr(AppKit, "NSApplication")
NSRunningApplication: Any = getattr(AppKit, "NSRunningApplication")
NSApplicationActivateIgnoringOtherApps: int = getattr(
    AppKit, "NSApplicationActivateIgnoringOtherApps"
)
NSApplicationActivateAllWindows: int = getattr(AppKit, "NSApplicationActivateAllWindows")
assert isinstance(NSApplicationActivateIgnoringOtherApps, int)
assert isinstance(NSApplicationActivateAllWindows, int)

GREETING_TITLE = "Say hi"
GREETING_MESSAGE = "Hi there!"
OPEN_UI_TITLE = f"Open {APP_NAME}"
OPEN_LOGS_TITLE = "Open Logs Folder"
SEE_DIAGNOSTICS_TITLE = "See Diagnostics"
QUIT_TITLE = "Quit"


def _is_apple_silicon_hardware() -> bool:
    """Check if running on Apple Silicon hardware (works even under Rosetta)."""
    result = subprocess.run(
        ["sysctl", "-n", "hw.optional.arm64"],
        capture_output=True,
        text=True,
    )
    return result.returncode == 0 and result.stdout.strip() == "1"


def require_apple_silicon() -> None:
    """Ensure we're running on an Apple Silicon Mac (M1/M2/M3/M4, etc.)."""
    if platform.system() != "Darwin":
        raise RuntimeError("The menu bar helper only runs on macOS.")
    if not _is_apple_silicon_hardware():
        raise RuntimeError(
            "The menu bar helper requires Apple Silicon hardware (M1/M2/M3/M4, etc.)."
        )


class MenuBarApp(rumps.App):
    """Simple macOS status bar app with a single greeting button."""

    def __init__(
        self,
        enable_alerts: bool = True,
        app_support_dir: Optional[str] = None,
        server_enabled: bool = True,
        server_host: str = "127.0.0.1",
        server_port: Optional[int] = None,
        textual_target: str = TEXTUAL_APP_SPEC,
        server_ready_timeout: float = 3.0,
        server_ready_interval: float = 0.1,
        window_title: str = APP_NAME,
        window_width: int = 1000,
        window_height: int = 700,
        window_resizable: bool = False,
        window_frameless: bool = False,
        window_easy_drag: bool = True,
        diagnostics_window_title: str = f"{APP_NAME} Diagnostics",
        diagnostics_window_width: int = 1400,
        diagnostics_window_height: int = 900,
        diagnostics_window_resizable: bool = True,
        diagnostics_window_screen_fraction: float | None = 0.75,
        initialize: bool = True,
    ) -> None:
        self.enable_alerts = enable_alerts
        self.server_enabled = server_enabled
        self.server_host = server_host
        self._server_port = server_port
        self.textual_target = textual_target
        self.server_ready_timeout = 0.0 if not initialize else server_ready_timeout
        self.server_ready_interval = server_ready_interval
        self.window_title = window_title
        self.window_width = window_width
        self.window_height = window_height
        self.window_resizable = window_resizable
        self.window_frameless = window_frameless
        self.window_easy_drag = window_easy_drag
        self.diagnostics_window_title = diagnostics_window_title
        self.diagnostics_window_width = diagnostics_window_width
        self.diagnostics_window_height = diagnostics_window_height
        self.diagnostics_window_resizable = diagnostics_window_resizable
        self.diagnostics_window_screen_fraction = diagnostics_window_screen_fraction
        self._app_support_dir = app_support_dir
        self._server_proc: subprocess.Popen[bytes] | None = None
        self._server_log_file: IO[bytes] | None = None
        self._webview_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_log_file: IO[bytes] | None = None
        self._diagnostics_webview_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_port: Optional[int] = None
        self._quit_watch_timer: Optional[rumps.Timer] = None
        self._parent_watch_read_fd: int | None = None
        self._parent_watch_write_fd: int | None = None
        if initialize:
            self._parent_watch_read_fd, self._parent_watch_write_fd = create_parent_watch_pipe()
        if initialize and app_support_dir:
            base = Path(app_support_dir)
            base.mkdir(parents=True, exist_ok=True)

            def _application_support(_name: str) -> str:
                base.mkdir(parents=True, exist_ok=True)
                return str(base)

            assert hasattr(rumps, "application_support")
            setattr(rumps, "application_support", _application_support)
            assert hasattr(rumps_utils, "application_support")
            setattr(rumps_utils, "application_support", _application_support)

        super().__init__(APP_NAME, quit_button=None)  # type: ignore[misc]
        if not initialize:
            self.hi_item = SimpleNamespace(title=GREETING_TITLE)
            self.open_item = SimpleNamespace(title=OPEN_UI_TITLE)
            self.logs_item = SimpleNamespace(title=OPEN_LOGS_TITLE)
            self.diagnostics_item = SimpleNamespace(title=SEE_DIAGNOSTICS_TITLE)
            self.quit_item = SimpleNamespace(title=QUIT_TITLE)
            return
        self._register_signal_handlers()
        atexit.register(self._stop_server)
        atexit.register(self._stop_webview)
        atexit.register(self._stop_diagnostics_server)
        atexit.register(self._stop_diagnostics_webview)
        self.hi_item = rumps.MenuItem(GREETING_TITLE, callback=self._on_hi_clicked)
        self.open_item = rumps.MenuItem(OPEN_UI_TITLE, callback=self._on_open_clicked)
        self.logs_item = rumps.MenuItem(OPEN_LOGS_TITLE, callback=self._on_open_logs_clicked)
        self.diagnostics_item = rumps.MenuItem(
            SEE_DIAGNOSTICS_TITLE, callback=self._on_diagnostics_clicked
        )
        self.quit_item = rumps.MenuItem(QUIT_TITLE, callback=self._on_quit_clicked)
        self.menu = [
            self.open_item,
            self.logs_item,
            self.diagnostics_item,
            self.hi_item,
            self.quit_item,
        ]
        self._start_quit_watch()
        if self.server_enabled:
            self._ensure_server()

    def _on_hi_clicked(self, _sender: object) -> str:
        if self.enable_alerts:
            self._activate_app()
            self._alert(APP_NAME, GREETING_MESSAGE)
        return GREETING_MESSAGE

    def _on_open_clicked(self, _sender: object) -> str:
        if not self._ensure_server():
            return ""
        url = self._current_url()
        if not self._open_webview(url):
            webbrowser.open(url)
        return url

    def _on_open_logs_clicked(self, _sender: object) -> str:
        log_dir = self._log_dir()
        env_hint = f"(override with ${LOG_DIR_ENV})"
        if log_dir.exists():
            subprocess.Popen(["open", str(log_dir)])
        elif self.enable_alerts:
            self._alert(
                APP_NAME,
                f"Logs directory not found yet: {log_dir}\n{env_hint}",
            )
        return str(log_dir)

    def _on_diagnostics_clicked(self, _sender: object) -> str:
        if not self._ensure_diagnostics_server():
            if self.enable_alerts:
                self._alert(
                    APP_NAME,
                    "Diagnostics viewer unavailable. Install textual-serve to open logs.",
                )
            return ""
        url = self._diagnostics_url()
        if not self._open_diagnostics_webview(url):
            webbrowser.open(url)
        return url

    def _on_quit_clicked(self, _sender: object) -> None:
        self._shutdown()
        self._quit_application()

    def _current_url(self) -> str:
        port = self._server_port or 0
        return f"http://{self.server_host}:{port}"

    def _ensure_server(self) -> bool:
        if not self.server_enabled:
            return False
        if self._server_proc and self._server_proc.poll() is None:
            return self._wait_for_server_ready()
        if not self._start_server():
            return False
        if self._wait_for_server_ready():
            return True
        self._stop_server()
        if self.enable_alerts:
            self._alert(
                APP_NAME,
                f"{APP_NAME} UI failed to start. Try again or run it from the terminal for details.",
            )
        return False

    def _start_server(self) -> bool:
        port = self._server_port or self._find_free_port()
        self._server_port = port
        cmd = self._server_command(port)
        if cmd is None:
            if self.enable_alerts:
                self._alert(
                    APP_NAME,
                    "Textual web server is missing. Install textual-serve and try again.",
                )
            return False
        log_path = self._server_log_path()
        log_path.parent.mkdir(parents=True, exist_ok=True)
        log_file = open(log_path, "ab")
        try:
            self._server_proc = subprocess.Popen(
                cmd,
                stdout=log_file,
                stderr=subprocess.STDOUT,
                env=self._server_env(),
                start_new_session=True,
                pass_fds=self._parent_watch_fds(),
            )
        except Exception:
            log_file.close()
            raise
        self._server_log_file = log_file
        return True

    def _server_command(self, port: int) -> list[str] | None:
        if importlib.util.find_spec("textual_serve") is None:
            return None
        return [
            sys.executable,
            "-m",
            importlib.import_module(".textual_serve_runner", __package__).__name__,
            "--host",
            self.server_host,
            "--port",
            str(port),
            "--app",
            self.textual_target,
        ]

    def _server_log_path(self) -> Path:
        return log_path("menubar-server.log", self._app_support_dir)

    def _log_dir(self) -> Path:
        if self._app_support_dir:
            return Path(self._app_support_dir)
        return default_log_dir()

    def _server_env(self) -> dict[str, str]:
        env = os.environ.copy()
        if LOG_DIR_ENV not in env:
            env[LOG_DIR_ENV] = str(self._log_dir())
        if self._parent_watch_read_fd is not None:
            env[PARENT_FD_ENV] = str(self._parent_watch_read_fd)
        env[PARENT_PID_ENV] = str(os.getpid())
        source_root = str(Path(__file__).resolve().parents[1])
        pythonpath = env.get("PYTHONPATH", "")
        paths = [path for path in pythonpath.split(os.pathsep) if path]
        if source_root not in paths:
            paths.insert(0, source_root)
        env["PYTHONPATH"] = os.pathsep.join(paths)
        return env

    def _parent_watch_fds(self) -> tuple[int, ...]:
        if self._parent_watch_read_fd is None or os.name == "nt":
            return ()
        return (self._parent_watch_read_fd,)

    def _open_webview(self, url: str) -> bool:
        if self._webview_proc and self._webview_proc.poll() is None:
            self._bring_to_front(self.window_title)
            return True
        cmd = self._webview_command(url)
        if cmd is None:
            if self.enable_alerts:
                self._alert(
                    APP_NAME,
                    "Native window requires pywebview. Install it to avoid opening a browser.",
                )
            return False
        self._webview_proc = subprocess.Popen(
            cmd,
            env=self._server_env(),
            start_new_session=True,
            pass_fds=self._parent_watch_fds(),
        )
        self._bring_to_front(self.window_title)
        return True

    def _webview_command(self, url: str) -> list[str] | None:
        if importlib.util.find_spec("webview") is None:
            return None
        cmd = [
            sys.executable,
            "-m",
            webview_app.__name__,
            "--url",
            url,
            "--title",
            self.window_title,
            "--width",
            str(self.window_width),
            "--height",
            str(self.window_height),
        ]
        cmd.append("--resizable" if self.window_resizable else "--no-resizable")
        cmd.append("--frameless" if self.window_frameless else "--no-frameless")
        cmd.append("--easy-drag" if self.window_easy_drag else "--no-easy-drag")
        return cmd

    def _wait_for_server_ready(self) -> bool:
        if self._server_port is None:
            return False
        if self.server_ready_timeout <= 0:
            return True
        deadline = time.monotonic() + self.server_ready_timeout
        while time.monotonic() < deadline:
            if self._server_proc and self._server_proc.poll() is not None:
                return False
            try:
                with socket.create_connection(
                    (self.server_host, self._server_port),
                    timeout=min(self.server_ready_interval, 0.5),
                ):
                    return True
            except OSError:
                time.sleep(self.server_ready_interval)
        return False

    def _diagnostics_url(self) -> str:
        port = self._diagnostics_port or 0
        return f"http://{self.server_host}:{port}"

    def _ensure_diagnostics_server(self) -> bool:
        if self._diagnostics_proc and self._diagnostics_proc.poll() is None:
            return self._wait_for_diagnostics_ready()
        if not self._start_diagnostics_server():
            return False
        if self._wait_for_diagnostics_ready():
            return True
        self._stop_diagnostics_server()
        return False

    def _wait_for_diagnostics_ready(self) -> bool:
        if self._diagnostics_port is None:
            return False
        if self.server_ready_timeout <= 0:
            return True
        deadline = time.monotonic() + self.server_ready_timeout
        while time.monotonic() < deadline:
            if self._diagnostics_proc and self._diagnostics_proc.poll() is not None:
                return False
            try:
                with socket.create_connection(
                    (self.server_host, self._diagnostics_port),
                    timeout=min(self.server_ready_interval, 0.5),
                ):
                    return True
            except OSError:
                time.sleep(self.server_ready_interval)
        return False

    def _start_diagnostics_server(self) -> bool:
        port = self._diagnostics_port or self._find_free_port()
        self._diagnostics_port = port
        cmd = self._diagnostics_server_command(port)
        if cmd is None:
            return False
        log_path = self._diagnostics_log_path()
        log_path.parent.mkdir(parents=True, exist_ok=True)
        log_file = open(log_path, "ab")
        try:
            self._diagnostics_proc = subprocess.Popen(
                cmd,
                stdout=log_file,
                stderr=subprocess.STDOUT,
                env=self._server_env(),
                start_new_session=True,
                pass_fds=self._parent_watch_fds(),
            )
        except Exception:
            log_file.close()
            raise
        self._diagnostics_log_file = log_file
        return True

    def _diagnostics_server_command(self, port: int) -> list[str] | None:
        if importlib.util.find_spec("textual_serve") is None:
            return None
        return [
            sys.executable,
            "-m",
            importlib.import_module(".textual_serve_runner", __package__).__name__,
            "--host",
            self.server_host,
            "--port",
            str(port),
            "--app",
            DIAGNOSTICS_APP_SPEC,
        ]

    def _diagnostics_log_path(self) -> Path:
        return log_path("diagnostics-server.log", self._app_support_dir)

    def _open_diagnostics_webview(self, url: str) -> bool:
        if self._diagnostics_webview_proc and self._diagnostics_webview_proc.poll() is None:
            self._bring_to_front(self.diagnostics_window_title)
            return True
        cmd = self._diagnostics_webview_command(url)
        if cmd is None:
            return False
        self._diagnostics_webview_proc = subprocess.Popen(
            cmd,
            env=self._server_env(),
            start_new_session=True,
            pass_fds=self._parent_watch_fds(),
        )
        self._bring_to_front(self.diagnostics_window_title)
        return True

    def _diagnostics_webview_command(self, url: str) -> list[str] | None:
        if importlib.util.find_spec("webview") is None:
            return None
        cmd = [
            sys.executable,
            "-m",
            webview_app.__name__,
            "--url",
            url,
            "--title",
            self.diagnostics_window_title,
            "--width",
            str(self.diagnostics_window_width),
            "--height",
            str(self.diagnostics_window_height),
        ]
        if self.diagnostics_window_screen_fraction is not None:
            cmd.extend(["--screen-fraction", str(self.diagnostics_window_screen_fraction)])
        cmd.append("--resizable" if self.diagnostics_window_resizable else "--no-resizable")
        cmd.append("--frameless" if self.window_frameless else "--no-frameless")
        cmd.append("--no-easy-drag")
        return cmd

    def _find_free_port(self) -> int:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.bind((self.server_host, 0))
            return sock.getsockname()[1]

    def _stop_server(self) -> None:
        if self._server_proc and self._server_proc.poll() is None:
            self._terminate_process_group(self._server_proc)
        if self._server_log_file:
            self._server_log_file.close()
            self._server_log_file = None

    def _stop_webview(self) -> None:
        if self._webview_proc and self._webview_proc.poll() is None:
            self._terminate_process_group(self._webview_proc)

    def _stop_diagnostics_server(self) -> None:
        if self._diagnostics_proc and self._diagnostics_proc.poll() is None:
            self._terminate_process_group(self._diagnostics_proc)
        if self._diagnostics_log_file:
            self._diagnostics_log_file.close()
            self._diagnostics_log_file = None

    def _stop_diagnostics_webview(self) -> None:
        if self._diagnostics_webview_proc and self._diagnostics_webview_proc.poll() is None:
            self._terminate_process_group(self._diagnostics_webview_proc)

    def _terminate_process_group(self, proc: subprocess.Popen[bytes]) -> None:
        if os.name == "nt" or not hasattr(os, "killpg"):
            proc.terminate()
            try:
                proc.wait(timeout=3)
            except subprocess.TimeoutExpired:
                proc.kill()
            return
        try:
            os.killpg(proc.pid, signal.SIGTERM)
        except ProcessLookupError:
            return
        try:
            proc.wait(timeout=3)
        except subprocess.TimeoutExpired:
            try:
                os.killpg(proc.pid, signal.SIGKILL)
            except ProcessLookupError:
                return

    def _register_signal_handlers(self) -> None:
        for sig in (signal.SIGTERM, signal.SIGINT):
            signal.signal(sig, self._handle_signal)

    def _handle_signal(self, _signum: int, _frame: object | None) -> None:
        self._shutdown()
        raise SystemExit(0)

    def _shutdown(self) -> None:
        self._close_parent_watch()
        self._stop_diagnostics_webview()
        self._stop_diagnostics_server()
        self._stop_webview()
        self._stop_server()

    def _close_parent_watch(self) -> None:
        if self._parent_watch_write_fd is not None:
            try:
                os.close(self._parent_watch_write_fd)
            except OSError:
                pass
            self._parent_watch_write_fd = None
        if self._parent_watch_read_fd is not None:
            try:
                os.close(self._parent_watch_read_fd)
            except OSError:
                pass
            self._parent_watch_read_fd = None

    def _start_quit_watch(self) -> None:
        self._quit_watch_timer = rumps.Timer(self._poll_quit_signal, 0.25)
        self._quit_watch_timer.start()

    def _poll_quit_signal(self, _timer: rumps.Timer) -> None:
        ui_signal = log_path(QUIT_SIGNAL_FILENAME, self._app_support_dir)
        if ui_signal.exists():
            try:
                ui_signal.unlink()
            except OSError:
                return
            self._stop_webview()
            self._stop_server()
            return
        diagnostics_signal = log_path(DIAGNOSTICS_QUIT_SIGNAL_FILENAME, self._app_support_dir)
        if not diagnostics_signal.exists():
            return
        try:
            diagnostics_signal.unlink()
        except OSError:
            return
        self._stop_diagnostics_webview()
        self._stop_diagnostics_server()

    def _alert(self, title: str, message: str) -> None:
        alert = getattr(rumps, "alert", None)
        assert callable(alert)
        alert(title, message)

    def _quit_application(self) -> None:
        quit_application = getattr(rumps, "quit_application", None)
        assert callable(quit_application)
        quit_application()

    def _activate_app(self) -> None:
        """Bring the current application to the front using NSApplication."""
        if platform.system() != "Darwin":
            return
        # pyright: ignore[reportUnknownMemberType,reportUnknownVariableType]
        app: Any = NSApplication.sharedApplication()  # type: ignore[reportUnknownMemberType]
        app.activateIgnoringOtherApps_(True)  # type: ignore[reportUnknownMemberType]
        if hasattr(app, "unhide_"):
            app.unhide_(None)  # type: ignore[reportUnknownMemberType]
        if hasattr(app, "arrangeInFront_"):
            app.arrangeInFront_(None)  # type: ignore[reportUnknownMemberType]
        running_app = NSRunningApplication.currentApplication()  # type: ignore[reportUnknownMemberType]
        if running_app is None:
            return
        options = NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows
        running_app.activateWithOptions_(options)  # type: ignore[reportUnknownMemberType]

    def _bring_to_front(self, title: str) -> None:
        if platform.system() != "Darwin":
            return
        safe_title = title.replace("\\", "\\\\").replace('"', '\\"')
        safe_title = safe_title.replace("\n", "\\n").replace("\r", "\\n")
        script = f'tell application "{safe_title}" to activate'
        subprocess.run(["osascript", "-e", script], capture_output=True, text=True)


def run_menu_bar() -> None:
    require_apple_silicon()
    MenuBarApp().run()  # type: ignore[call-arg]


if __name__ == "__main__":
    run_menu_bar()
</file>

<file path="src/app/textual_app_runner.py">
from __future__ import annotations

import argparse
import importlib
from collections.abc import Callable
from typing import Any, TypeGuard

from textual.app import App

from .parent_watch import start_parent_watchdog_from_env


def resolve_app(spec: str) -> App[Any]:
    module_name, sep, attr_name = spec.partition(":")
    if not module_name or not sep or not attr_name:
        raise ValueError("App spec must be in the form module:attribute")
    try:
        module = importlib.import_module(module_name)
    except ModuleNotFoundError as exc:
        raise ModuleNotFoundError(
            f"Module {module_name!r} was not found. Check the module name."
        ) from exc
    except ImportError as exc:
        raise ImportError(
            f"Module {module_name!r} could not be imported. "
            "Check the module name and its dependencies."
        ) from exc
    try:
        target: object = getattr(module, attr_name)
    except AttributeError as exc:
        raise AttributeError(
            f"Attribute {attr_name!r} was not found in module {module_name!r}. Check the app spec."
        ) from exc
    app: App[Any] | None = None

    def _is_app(value: object) -> TypeGuard[App[Any]]:
        return isinstance(value, App)

    def _is_app_type(value: object) -> TypeGuard[type[App[Any]]]:
        return isinstance(value, type) and issubclass(value, App)

    def _is_factory(value: object) -> TypeGuard[Callable[[], object]]:
        return callable(value)

    if _is_app(target):
        app = target
    elif _is_app_type(target):
        app = target()
    elif _is_factory(target):
        candidate = target()
        if _is_app(candidate):
            app = candidate
    if app is None:
        raise TypeError("App spec did not resolve to a Textual App")
    return app


def main(argv: list[str] | None = None) -> int:
    start_parent_watchdog_from_env()
    parser = argparse.ArgumentParser(description="Run a Textual App from a spec.")
    parser.add_argument("--app", required=True, help="App spec like package.module:AppClass")
    args = parser.parse_args(argv)
    app = resolve_app(args.app)
    app.run()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="tests/test_app.py">
import asyncio

import pytest

from app.app import demo_run
from app.loop import run


async def _current_loop_name() -> str:
    loop = asyncio.get_running_loop()
    return type(loop).__module__


def test_run_installs_uvloop() -> None:
    loop_name = run(_current_loop_name())
    assert "uvloop" in loop_name


@pytest.mark.asyncio
async def test_demo_run_defaults() -> None:
    assert await demo_run() == pytest.approx(2.0)


@pytest.mark.asyncio
async def test_demo_run_custom_values() -> None:
    assert await demo_run([10, 20]) == pytest.approx(15.0)
</file>

<file path="tests/test_menubar.py">
import platform
import sys

import pytest

from app import textual_serve_runner, webview_app
from app.branding import APP_NAME
from app.menubar import (
    GREETING_MESSAGE,
    GREETING_TITLE,
    OPEN_LOGS_TITLE,
    OPEN_UI_TITLE,
    QUIT_TITLE,
    SEE_DIAGNOSTICS_TITLE,
    MenuBarApp,
    require_apple_silicon,
)


def test_greeting_message_constant() -> None:
    assert GREETING_MESSAGE == "Hi there!"
    assert GREETING_TITLE == "Say hi"
    assert OPEN_UI_TITLE == f"Open {APP_NAME}"
    assert OPEN_LOGS_TITLE == "Open Logs Folder"
    assert SEE_DIAGNOSTICS_TITLE == "See Diagnostics"
    assert QUIT_TITLE == "Quit"


def test_require_apple_silicon() -> None:
    """Test that the function enforces macOS + Apple Silicon hardware."""
    from app.menubar import _is_apple_silicon_hardware

    is_macos = platform.system() == "Darwin"
    is_apple_silicon = is_macos and _is_apple_silicon_hardware()

    if is_apple_silicon:
        require_apple_silicon()  # Should pass
    else:
        with pytest.raises(RuntimeError):
            require_apple_silicon()


def test_menu_bar_app_sets_menu_item_title(tmp_path) -> None:
    app = MenuBarApp(enable_alerts=False, app_support_dir=str(tmp_path), initialize=False)
    assert app.hi_item.title == GREETING_TITLE
    assert app._on_hi_clicked(None) == GREETING_MESSAGE
    assert app.open_item.title == OPEN_UI_TITLE
    assert app.logs_item.title == OPEN_LOGS_TITLE
    assert app.diagnostics_item.title == SEE_DIAGNOSTICS_TITLE
    assert app.quit_item.title == QUIT_TITLE


def test_on_open_starts_server_and_opens_browser(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False, server_ready_timeout=0.0)
    started = {}

    def fake_start_server() -> bool:
        started["ok"] = True
        app._server_port = 4242
        return True

    opened = {}
    app._start_server = fake_start_server  # type: ignore[assignment]

    def fake_open_webview(_self, url: str) -> bool:
        opened["url"] = url
        return True

    monkeypatch.setattr("app.menubar.MenuBarApp._open_webview", fake_open_webview)

    url = app._on_open_clicked(None)
    assert started["ok"] is True
    assert opened["url"] == "http://127.0.0.1:4242"
    assert url == opened["url"]


def test_server_disabled_skips_start(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, server_enabled=False, initialize=False)

    def fail() -> None:
        raise AssertionError("server should not start when disabled")

    app._start_server = fail  # type: ignore[assignment]
    app._ensure_server()


def test_server_command_uses_runner(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)

    monkeypatch.setattr("app.menubar.importlib.util.find_spec", lambda name: object())
    cmd = app._server_command(4242)
    assert cmd is not None
    assert cmd[:3] == [sys.executable, "-m", textual_serve_runner.__name__]
    assert "--app" in cmd


def test_webview_command_includes_window_args(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)

    monkeypatch.setattr("app.menubar.importlib.util.find_spec", lambda name: object())
    cmd = app._webview_command("http://127.0.0.1:4242")
    assert cmd is not None
    assert cmd[:3] == [sys.executable, "-m", webview_app.__name__]
    assert "--url" in cmd
    assert "--title" in cmd
    assert "--no-frameless" in cmd
    assert "--easy-drag" in cmd


def test_diagnostics_webview_command_includes_screen_fraction(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)

    monkeypatch.setattr("app.menubar.importlib.util.find_spec", lambda name: object())
    cmd = app._diagnostics_webview_command("http://127.0.0.1:4242")
    assert cmd is not None
    assert "--screen-fraction" in cmd
    fraction_index = cmd.index("--screen-fraction") + 1
    assert cmd[fraction_index] == "0.75"
    assert "--resizable" in cmd
    assert "--no-easy-drag" in cmd


def test_quit_callback_invokes_shutdown(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)
    called = {}

    def fake_shutdown() -> None:
        called["shutdown"] = True

    def fake_quit_application() -> None:
        called["quit"] = True

    app._shutdown = fake_shutdown  # type: ignore[assignment]
    monkeypatch.setattr("app.menubar.rumps.quit_application", fake_quit_application)

    app._on_quit_clicked(None)
    assert called == {"shutdown": True, "quit": True}
</file>

</files>
