This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  latentscore/
    __init__.py
    __main__.py
    app.py
    computation.py
    diagnostics_tui.py
    logging_utils.py
    loop.py
    menubar.py
    textual_app_runner.py
    textual_app.py
    textual_serve_runner.py
    tui.py
    webview_app.py
tests/
  conftest.py
  test_app.py
  test_init.py
  test_logging_utils.py
  test_menubar.py
  test_textual_runners.py
  test_tui.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/latentscore/__main__.py">
from .app import main
from .loop import run

if __name__ == "__main__":
    run(main())
</file>

<file path="src/latentscore/computation.py">
from __future__ import annotations

from typing import Callable, Iterable

Number = float | int


async def mean_of(
    values: Iterable[Number],
    transform: Callable[[Number], Number] | None = None,
) -> float:
    numbers = list(values)
    if not numbers:
        return 0.0

    mapper: Callable[[Number], Number] = transform or (lambda x: x)
    mapped = list(map(mapper, numbers))
    return sum(mapped) / len(mapped)
</file>

<file path="src/latentscore/tui.py">
from __future__ import annotations

from textual.app import App, ComposeResult
from textual.widgets import Static

from .loop import install_uvloop_policy


class HelloWorldApp(App[None]):
    """Minimal Textual application that shows a hello world message."""

    CSS = """
    Screen {
        align: center middle;
    }

    #greeting {
        content-align: center middle;
    }
    """

    def compose(self) -> ComposeResult:
        yield Static("Hello world!", id="greeting")


def run_tui() -> None:
    """Install uvloop and run the hello world Textual app."""
    install_uvloop_policy()
    HelloWorldApp().run()


if __name__ == "__main__":
    run_tui()
</file>

<file path="tests/conftest.py">
import sys
from pathlib import Path

# Ensure the src package directory is importable when running tests without installation.
PROJECT_ROOT = Path(__file__).resolve().parents[1]
SRC_DIR = PROJECT_ROOT / "src"
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))
</file>

<file path="tests/test_init.py">
import latentscore


def test_menubar_reexports_are_accessible() -> None:
    MenuBarApp = getattr(latentscore, "MenuBarApp")
    run_menu_bar = getattr(latentscore, "run_menu_bar")

    assert MenuBarApp.__name__ == "MenuBarApp"
    assert callable(run_menu_bar)
</file>

<file path="tests/test_logging_utils.py">
import logging

from latentscore.logging_utils import LOG_DIR_ENV, default_log_dir, log_path, setup_file_logger


def test_log_path_uses_env_override(tmp_path, monkeypatch) -> None:
    monkeypatch.setenv(LOG_DIR_ENV, str(tmp_path))
    assert default_log_dir() == tmp_path
    assert log_path("demo.log") == tmp_path / "demo.log"


def test_setup_file_logger_creates_handler(tmp_path, monkeypatch) -> None:
    monkeypatch.setenv(LOG_DIR_ENV, str(tmp_path))
    logger_name = f"latentscore.test.{tmp_path.name}"
    path = setup_file_logger(logger_name, "app.log")
    assert path == tmp_path / "app.log"
    logger = logging.getLogger(logger_name)
    assert any(isinstance(handler, logging.FileHandler) for handler in logger.handlers)
</file>

<file path="tests/test_textual_runners.py">
from latentscore.textual_app_runner import resolve_app
from latentscore.textual_serve_runner import build_command


def test_resolve_app_from_class() -> None:
    app = resolve_app("latentscore.textual_app:LatentScoreApp")
    assert app.__class__.__name__ == "LatentScoreApp"


def test_build_command_contains_runner() -> None:
    cmd = build_command("latentscore.textual_app:LatentScoreApp")
    assert "latentscore.textual_app_runner" in cmd
</file>

<file path="tests/test_tui.py">
import pytest
from textual.widgets import Static

from latentscore.tui import HelloWorldApp


@pytest.mark.asyncio
async def test_hello_world_app_renders_greeting() -> None:
    async with HelloWorldApp().run_test() as pilot:
        greeting = pilot.app.query_one("#greeting", Static)
        rendered = greeting.render()
        assert "Hello world!" in str(rendered)
</file>

<file path="src/latentscore/app.py">
from __future__ import annotations

from typing import Iterable

from dependency_injector import containers, providers

from .computation import mean_of


class Container(containers.DeclarativeContainer):
    mean = providers.Callable(mean_of)


async def demo_run(values: Iterable[float] | None = None) -> float:
    container = Container()
    sample = values if values is not None else (1.0, 2.0, 3.0)
    return await container.mean(sample)


async def main() -> None:
    result = await demo_run()
    print(f"Sample mean: {result:.2f}")
</file>

<file path="src/latentscore/diagnostics_tui.py">
from __future__ import annotations

import argparse
from dataclasses import dataclass, field
from pathlib import Path

from textual import events
from textual.actions import SkipAction
from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Horizontal, Vertical
from textual.widgets import Footer, Header, Input, Static, TextArea

from .logging_utils import DIAGNOSTICS_QUIT_SIGNAL_FILENAME, LOG_DIR_ENV, default_log_dir
from .loop import install_uvloop_policy


def _empty_lines() -> list[str]:
    return []


@dataclass
class _LogPane:
    title: str
    path: Path
    widget: TextArea
    position: int = 0
    missing_noted: bool = False
    lines: list[str] = field(default_factory=_empty_lines)
    match_index: int = -1
    highlight_line: int | None = None


class DiagnosticsHeader(Header):
    app: "DiagnosticsApp"

    def _on_click(self) -> None:
        return

    def watch_tall(self, tall: bool) -> None:
        self.set_class(False, "-tall")

    def on_mouse_down(self, event: events.MouseDown) -> None:
        if event.button == 1:
            app = self.app
            assert isinstance(app, DiagnosticsApp)
            app.action_show_help()


class DiagnosticsApp(App[None]):
    """Textual log viewer for LatentScore diagnostics."""

    _inherit_bindings = False
    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("f", "toggle_follow", "Follow"),
        Binding("r", "reload", "Reload"),
        Binding("meta+c,super+c", "copy_selection", "Copy", show=False),
        Binding("/", "focus_search", "Search"),
        Binding("escape", "close_search", "Close Search"),
        Binding("n", "search_next", "Next Match"),
        Binding("N", "search_prev", "Prev Match"),
        Binding("?", "show_help", "Help"),
        Binding("h", "show_help", "Help"),
    ]

    # Minimal CSS for layout only - widget styling done via native SDK
    CSS = """
    Screen {
        layout: vertical;
    }

    #logs {
        height: 1fr;
        border-top: solid $secondary;
    }

    #search-bar {
        display: none;
        height: auto;
        padding: 1;
        background: $surface;
        border-bottom: solid $secondary;
    }

    #search-bar.visible {
        display: block;
    }

    #search-label {
        padding-right: 1;
        padding-top: 1;
        height: 3;
        content-align: center middle;
    }

    #search-input {
        width: 1fr;
        border: tall $accent;
        background: $surface;
        color: $foreground;
        height: 3;
    }

    #help {
        display: none;
        padding: 1;
        background: $panel;
        border: tall $primary;
        dock: bottom;
        layer: overlay;
        width: 60%;
        height: auto;
    }

    #help.visible {
        display: block;
    }

    .pane {
        width: 1fr;
    }

    .pane-title {
        padding: 0 1;
        background: $surface;
        color: $text-muted;
    }

    TextArea {
        height: 1fr;
    }

    TextArea .text-area--selection {
        background: $accent 40%;
    }
    """

    def __init__(self, log_dir: Path, *, max_lines: int = 5000) -> None:
        super().__init__()
        self._log_dir = log_dir
        self._max_lines = max_lines
        self._follow = True
        self._search_query: str | None = None
        self._search_visible = False
        self._active_pane: _LogPane | None = None
        self._panes: list[_LogPane] = []
        # Use TextArea for proper text selection and copy support
        self._menubar_log = TextArea(id="menubar-log", read_only=True)
        self._ui_log = TextArea(id="ui-log", read_only=True)
        self._search_input = Input(placeholder="Type and press Enter", id="search-input")
        help_text = (
            "Diagnostics viewer\n"
            "  /      search (press Enter to jump)\n"
            "  n/N    next/prev match\n"
            "  f      toggle follow\n"
            "  r      reload logs\n"
            "  Cmd+C  copy selection\n"
            "  q      quit"
        )
        self._help = Static(help_text, id="help")

    def compose(self) -> ComposeResult:
        yield DiagnosticsHeader(show_clock=False)
        yield self._help
        with Horizontal(id="search-bar"):
            yield Static("Search:", id="search-label")
            yield self._search_input
        with Horizontal(id="logs"):
            with Vertical(classes="pane"):
                yield Static("Menubar Server", classes="pane-title")
                yield self._menubar_log
            with Vertical(classes="pane"):
                yield Static("Textual UI", classes="pane-title")
                yield self._ui_log
        yield Footer()

    def on_mount(self) -> None:
        self.notify("Diagnostics viewer mounted (runtime check).", timeout=2.0)
        self._panes = [
            _LogPane(
                "Menubar Server",
                self._log_dir / "menubar-server.log",
                self._menubar_log,
            ),
            _LogPane("Textual UI", self._log_dir / "textual-ui.log", self._ui_log),
        ]
        self._active_pane = self._panes[0]
        self._active_pane.widget.focus()
        self._load_initial()
        self.set_interval(0.35, self._poll_files)

    def action_toggle_follow(self) -> None:
        self._follow = not self._follow
        status = "on" if self._follow else "off"
        self.notify(f"Follow {status}", timeout=1.0)
        if self._follow:
            self._scroll_to_end_all()

    def action_reload(self) -> None:
        for pane in self._panes:
            pane.widget.load_text("")
            pane.position = 0
            pane.missing_noted = False
            pane.lines.clear()
            pane.match_index = -1
        self._load_initial()
        self.notify("Reloaded logs", timeout=1.0)

    def _scroll_to_end_all(self) -> None:
        """Scroll all log panes to the end."""
        for pane in self._panes:
            pane.widget.scroll_end(animate=False)

    def action_focus_search(self) -> None:
        self._search_visible = True
        self.query_one("#search-bar").add_class("visible")
        self._search_input.value = self._search_query or ""
        self._search_input.focus()

    def action_close_search(self) -> None:
        if not self._search_visible:
            return
        self._search_visible = False
        self.query_one("#search-bar").remove_class("visible")
        if self._active_pane:
            self._active_pane.widget.focus()

    def action_search_next(self) -> None:
        self._jump_match(1)

    def action_search_prev(self) -> None:
        self._jump_match(-1)

    def action_show_help(self) -> None:
        help_widget = self.query_one("#help")
        if "visible" in help_widget.classes:
            help_widget.remove_class("visible")
        else:
            help_widget.add_class("visible")

    def action_copy_selection(self) -> None:
        target = self.focused
        if isinstance(target, (TextArea, Input)):
            try:
                target.action_copy()
            except SkipAction:
                return
            return
        if self._active_pane is None:
            return
        try:
            self._active_pane.widget.action_copy()
        except SkipAction:
            return

    def on_focus(self, event: events.Focus) -> None:
        control = event.control
        if isinstance(control, TextArea):
            pane = self._pane_for_widget(control)
            if pane is not None:
                self._active_pane = pane

    def on_click(self, event: events.Click) -> None:
        if isinstance(event.control, Header):
            event.control.remove_class("-tall")

    def on_input_submitted(self, event: Input.Submitted) -> None:
        if event.input is not self._search_input:
            return
        query = event.value.strip()
        if not query:
            self._search_query = None
            if self._active_pane:
                self._active_pane.highlight_line = None
            self.notify("Search cleared", timeout=1.0)
            self.action_close_search()
            return
        self._follow = False
        self._search_query = query
        self._jump_match(1, reset=True)
        self.action_close_search()

    async def action_quit(self) -> None:
        signal_path = self._log_dir / DIAGNOSTICS_QUIT_SIGNAL_FILENAME
        signal_path.write_text("quit", encoding="utf-8")
        self.exit()

    def _load_initial(self) -> None:
        for pane in self._panes:
            if not pane.path.exists():
                if not pane.missing_noted:
                    pane.lines.append(f"{pane.title} log not found yet at {pane.path}")
                    self._update_pane_text(pane)
                    pane.missing_noted = True
                continue
            text = pane.path.read_text(encoding="utf-8", errors="replace")
            lines = text.splitlines()
            tail = lines[-200:] if len(lines) > 200 else lines
            pane.lines.extend(tail)
            self._update_pane_text(pane)
            pane.position = pane.path.stat().st_size
        if self._follow:
            self._scroll_to_end_all()

    def _poll_files(self) -> None:
        any_updated = False
        for pane in self._panes:
            if not pane.path.exists():
                if not pane.missing_noted:
                    pane.lines.append(f"{pane.title} log not found yet at {pane.path}")
                    self._update_pane_text(pane)
                    pane.missing_noted = True
                continue
            try:
                size = pane.path.stat().st_size
            except OSError:
                continue
            if size < pane.position:
                pane.lines.clear()
                pane.match_index = -1
                pane.lines.append(f"{pane.title} log rotated")
                pane.position = 0
                self._update_pane_text(pane)
                any_updated = True
            with pane.path.open("r", encoding="utf-8", errors="replace") as handle:
                handle.seek(pane.position)
                chunk = handle.read()
                pane.position = handle.tell()
            if not chunk:
                continue
            new_lines = chunk.splitlines()
            pane.lines.extend(new_lines)
            # Trim to max_lines
            if len(pane.lines) > self._max_lines:
                pane.lines = pane.lines[-self._max_lines :]
            self._update_pane_text(pane)
            any_updated = True
        if any_updated and self._follow:
            self._scroll_to_end_all()

    def _update_pane_text(self, pane: _LogPane) -> None:
        """Update the TextArea content with all lines."""
        pane.widget.load_text("\n".join(pane.lines))

    def _pane_for_widget(self, widget: TextArea) -> _LogPane | None:
        for pane in self._panes:
            if pane.widget is widget:
                return pane
        return None

    def _jump_match(self, direction: int, *, reset: bool = False) -> None:
        if not self._search_query:
            self.notify("No active search", timeout=1.0)
            return
        pane = self._active_pane
        if pane is None:
            return
        matches = self._search_matches(pane, self._search_query)
        if not matches:
            self.notify(f"No matches for {self._search_query!r}", timeout=1.0)
            pane.match_index = -1
            pane.highlight_line = None
            return
        if reset or pane.match_index < 0:
            pane.match_index = 0
        else:
            pane.match_index = (pane.match_index + direction) % len(matches)
        line_index = matches[pane.match_index]
        pane.highlight_line = line_index
        # Move cursor to the matching line and select it
        pane.widget.focus()
        pane.widget.move_cursor((line_index, 0))
        pane.widget.select_line(line_index)
        self.notify(
            f"{pane.title}: match {pane.match_index + 1}/{len(matches)}",
            timeout=1.0,
        )

    def _search_matches(self, pane: _LogPane, query: str) -> list[int]:
        target = query.lower()
        return [idx for idx, line in enumerate(pane.lines) if target in line.lower()]


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="LatentScore diagnostics viewer")
    parser.add_argument(
        "--log-dir",
        type=Path,
        default=default_log_dir(),
        help=f"Log directory (default: ${LOG_DIR_ENV} or platform default)",
    )
    return parser.parse_args()


def build_app(log_dir: Path | None = None) -> DiagnosticsApp:
    install_uvloop_policy()
    return DiagnosticsApp(log_dir or default_log_dir())


def run() -> None:
    args = _parse_args()
    build_app(args.log_dir).run()


if __name__ == "__main__":
    run()
</file>

<file path="src/latentscore/logging_utils.py">
from __future__ import annotations

import logging
import os
import platform
from pathlib import Path

LOG_DIR_ENV = "LATENTSCORE_LOG_DIR"
LOG_DIR_NAME = "LatentScore"
QUIT_SIGNAL_FILENAME = "textual-ui.quit"
DIAGNOSTICS_QUIT_SIGNAL_FILENAME = "diagnostics-ui.quit"


def default_log_dir() -> Path:
    env_dir = os.environ.get(LOG_DIR_ENV)
    if env_dir:
        return Path(env_dir).expanduser()
    if platform.system() == "Darwin":
        return Path.home() / "Library" / "Logs" / LOG_DIR_NAME
    return Path.home() / ".latentscore" / "logs"


def log_path(filename: str, app_support_dir: str | None = None) -> Path:
    base_dir = Path(app_support_dir) if app_support_dir else default_log_dir()
    return base_dir / filename


def setup_file_logger(
    name: str,
    filename: str,
    *,
    level: int = logging.INFO,
    app_support_dir: str | None = None,
) -> Path:
    logger = logging.getLogger(name)
    if logger.handlers:
        return log_path(filename, app_support_dir)
    logger.setLevel(level)
    path = log_path(filename, app_support_dir)
    path.parent.mkdir(parents=True, exist_ok=True)
    handler = logging.FileHandler(path)
    handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s"))
    logger.addHandler(handler)
    return path
</file>

<file path="src/latentscore/loop.py">
from __future__ import annotations

import asyncio
from typing import Coroutine, TypeVar

import uvloop

T = TypeVar("T")


def install_uvloop_policy() -> None:
    """Install uvloop as the default event loop policy."""
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())


def run(coro: Coroutine[object, object, T]) -> T:
    """Run a coroutine with uvloop installed."""
    install_uvloop_policy()
    return asyncio.run(coro)
</file>

<file path="src/latentscore/textual_app_runner.py">
from __future__ import annotations

import argparse
import importlib
from collections.abc import Callable
from typing import Any, TypeGuard

from textual.app import App


def resolve_app(spec: str) -> App[Any]:
    module_name, sep, attr_name = spec.partition(":")
    if not module_name or not sep or not attr_name:
        raise ValueError("App spec must be in the form module:attribute")
    module = importlib.import_module(module_name)
    target: object = getattr(module, attr_name)
    app: App[Any] | None = None

    def _is_app(value: object) -> TypeGuard[App[Any]]:
        return isinstance(value, App)

    def _is_app_type(value: object) -> TypeGuard[type[App[Any]]]:
        return isinstance(value, type) and issubclass(value, App)

    def _is_factory(value: object) -> TypeGuard[Callable[[], object]]:
        return callable(value)

    if _is_app(target):
        app = target
    elif _is_app_type(target):
        app = target()
    elif _is_factory(target):
        candidate = target()
        if _is_app(candidate):
            app = candidate
    if app is None:
        raise TypeError("App spec did not resolve to a Textual App")
    return app


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Run a Textual App from a spec.")
    parser.add_argument("--app", required=True, help="App spec like package.module:AppClass")
    args = parser.parse_args(argv)
    app = resolve_app(args.app)
    app.run()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="src/latentscore/textual_serve_runner.py">
from __future__ import annotations

import argparse
import shlex
import sys

from textual_serve.server import Server


def build_command(app_spec: str) -> str:
    args = [sys.executable, "-m", "latentscore.textual_app_runner", "--app", app_spec]
    return shlex.join(args)


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Serve a Textual app over the web.")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=8000)
    parser.add_argument("--app", required=True, help="App spec like package.module:AppClass")
    args = parser.parse_args(argv)

    command = build_command(args.app)
    print(f"textual-serve starting for {args.app} on {args.host}:{args.port}")
    Server(command=command, host=args.host, port=args.port).serve()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="src/latentscore/webview_app.py">
from __future__ import annotations

import argparse
import importlib
import platform
from importlib.util import find_spec


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Open a webview window.")
    parser.add_argument("--url", required=True)
    parser.add_argument("--title", default="LatentScore")
    parser.add_argument("--width", type=int, default=1000)
    parser.add_argument("--height", type=int, default=700)
    parser.add_argument(
        "--resizable",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Allow the window to be resized.",
    )
    parser.add_argument(
        "--frameless",
        default=False,
        action=argparse.BooleanOptionalAction,
        help="Render the window without the native frame.",
    )
    parser.add_argument(
        "--easy-drag",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Enable easy drag mode for frameless windows.",
    )
    args = parser.parse_args(argv)

    webview = importlib.import_module("webview")
    menu_module = importlib.import_module("webview.menu")
    menu_cls = getattr(menu_module, "Menu", None)
    menu_action_cls = getattr(menu_module, "MenuAction", None)
    assert menu_cls is not None
    assert menu_action_cls is not None

    if platform.system() == "Darwin":
        _set_app_name(args.title)

    def show_yolo_dialog() -> None:
        windows = getattr(webview, "windows", None)
        if not windows:
            return
        window = windows[0]
        evaluate_js = getattr(window, "evaluate_js", None)
        assert callable(evaluate_js)
        evaluate_js("alert('YOLO Test')")

    menu = [menu_cls("YOLO Test", [menu_action_cls("Show dialog", show_yolo_dialog)])]
    create_window = getattr(webview, "create_window", None)
    assert callable(create_window)
    create_window(
        args.title,
        args.url,
        width=args.width,
        height=args.height,
        resizable=args.resizable,
        frameless=args.frameless,
        easy_drag=args.easy_drag,
        menu=menu,
    )
    start = getattr(webview, "start", None)
    assert callable(start)
    start()
    return 0


def _set_app_name(title: str) -> None:
    if find_spec("Foundation") is None or find_spec("webview.platforms.cocoa") is None:
        return

    foundation = importlib.import_module("Foundation")
    cocoa = importlib.import_module("webview.platforms.cocoa")
    ns_process_info = getattr(foundation, "NSProcessInfo", None)
    assert ns_process_info is not None
    process_info = ns_process_info.processInfo()
    set_name = getattr(process_info, "setProcessName_", None)
    assert callable(set_name)
    set_name(title)
    info = getattr(cocoa, "info", None)
    if info is None:
        return
    setter = getattr(info, "__setitem__", None)
    if not callable(setter):
        return
    setter("CFBundleName", title)


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="tests/test_app.py">
import asyncio

import pytest

from latentscore.app import demo_run
from latentscore.loop import run


async def _current_loop_name() -> str:
    loop = asyncio.get_running_loop()
    return type(loop).__module__


def test_run_installs_uvloop() -> None:
    loop_name = run(_current_loop_name())
    assert "uvloop" in loop_name


@pytest.mark.asyncio
async def test_demo_run_defaults() -> None:
    assert await demo_run() == pytest.approx(2.0)


@pytest.mark.asyncio
async def test_demo_run_custom_values() -> None:
    assert await demo_run([10, 20]) == pytest.approx(15.0)
</file>

<file path="src/latentscore/__init__.py">
from __future__ import annotations

from importlib import import_module
from typing import TYPE_CHECKING

from .app import demo_run, main
from .loop import install_uvloop_policy, run
from .tui import HelloWorldApp, run_tui

if TYPE_CHECKING:
    from .menubar import MenuBarApp, run_menu_bar

__all__ = [
    "demo_run",
    "HelloWorldApp",
    "install_uvloop_policy",
    "main",
    "MenuBarApp",
    "run",
    "run_menu_bar",
    "run_tui",
]


def __getattr__(name: str) -> object:
    if name in {"MenuBarApp", "run_menu_bar"}:
        module = import_module(".menubar", __name__)
        return getattr(module, name)
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


def __dir__() -> list[str]:
    return sorted(__all__ + ["MenuBarApp", "run_menu_bar"])
</file>

<file path="src/latentscore/textual_app.py">
from __future__ import annotations

import logging
from typing import ClassVar

from textual import events
from textual.app import App, ComposeResult
from textual.binding import BindingType
from textual.containers import Vertical
from textual.widgets import Footer, Header, Static

from .logging_utils import QUIT_SIGNAL_FILENAME, log_path, setup_file_logger

LOGGER_NAME = "latentscore.textual"


class NonTallHeader(Header):
    """Header that keeps the tall flag disabled on click."""

    def _on_click(self) -> None:
        """Call through for now; this inexplicably avoids the titlebar glitch."""
        # We don't know why this variant behaves correctly, but it does in practice.
        super()._on_click()

    def watch_tall(self, tall: bool) -> None:
        """Keep the header in short mode even if tall gets toggled."""
        self.set_class(False, "-tall")


class LatentScoreApp(App[None]):
    """Minimal Textual app placeholder for the tracer bullet."""

    TITLE = "LatentScore"
    _inherit_bindings = False
    BINDINGS: ClassVar[list[BindingType]] = []

    def on_mount(self) -> None:
        log_file = setup_file_logger(LOGGER_NAME, "textual-ui.log")
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("LatentScoreApp mounted (log check).")
        logger.info("LatentScore logs at %s", log_file)

    def on_ready(self) -> None:
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("LatentScoreApp ready (log check).")

    def on_click(self, event: events.Click) -> None:
        if isinstance(event.control, NonTallHeader):
            logger = logging.getLogger(LOGGER_NAME)
            logger.info("Header clicked (log check).")
            event.control.remove_class("-tall")

    async def action_quit(self) -> None:
        signal_path = log_path(QUIT_SIGNAL_FILENAME)
        signal_path.write_text("quit", encoding="utf-8")
        logger = logging.getLogger(LOGGER_NAME)
        logger.info("Quit requested; wrote %s", signal_path)
        self.exit()

    def compose(self) -> ComposeResult:
        yield NonTallHeader(show_clock=False)
        with Vertical():
            yield Static("LatentScore is running via the menubar app.", id="body")
            yield Static("Use the menubar item to open this UI.", id="hint")
            yield Static(f"Logs: {log_path('textual-ui.log')}", id="logs")
        yield Footer()


def run() -> None:
    setup_file_logger(LOGGER_NAME, "textual-ui.log")
    logging.getLogger(LOGGER_NAME).info("Launching LatentScoreApp (log check).")
    LatentScoreApp().run()


if __name__ == "__main__":
    run()
</file>

<file path="src/latentscore/menubar.py">
from __future__ import annotations

import atexit
import importlib.util
import os
import platform
import signal
import socket
import subprocess
import sys
import time
import webbrowser
from pathlib import Path
from types import SimpleNamespace
from typing import IO, Any, Optional

import rumps  # type: ignore[import]
import AppKit  # type: ignore[import]
from rumps import utils as rumps_utils  # type: ignore[import]

from .logging_utils import (
    DIAGNOSTICS_QUIT_SIGNAL_FILENAME,
    LOG_DIR_ENV,
    QUIT_SIGNAL_FILENAME,
    default_log_dir,
    log_path,
)

NSApplication: Any = getattr(AppKit, "NSApplication")
NSRunningApplication: Any = getattr(AppKit, "NSRunningApplication")
NSApplicationActivateIgnoringOtherApps: int = getattr(
    AppKit, "NSApplicationActivateIgnoringOtherApps"
)
NSApplicationActivateAllWindows: int = getattr(AppKit, "NSApplicationActivateAllWindows")
assert isinstance(NSApplicationActivateIgnoringOtherApps, int)
assert isinstance(NSApplicationActivateAllWindows, int)

GREETING_TITLE = "Say hi"
GREETING_MESSAGE = "Hi there!"
OPEN_UI_TITLE = "Open LatentScore"
OPEN_LOGS_TITLE = "Open Logs Folder"
SEE_DIAGNOSTICS_TITLE = "See Diagnostics"
QUIT_TITLE = "Quit"


def _is_apple_silicon_hardware() -> bool:
    """Check if running on Apple Silicon hardware (works even under Rosetta)."""
    result = subprocess.run(
        ["sysctl", "-n", "hw.optional.arm64"],
        capture_output=True,
        text=True,
    )
    return result.returncode == 0 and result.stdout.strip() == "1"


def require_apple_silicon() -> None:
    """Ensure we're running on an Apple Silicon Mac (M1/M2/M3/M4, etc.)."""
    if platform.system() != "Darwin":
        raise RuntimeError("The menu bar helper only runs on macOS.")
    if not _is_apple_silicon_hardware():
        raise RuntimeError(
            "The menu bar helper requires Apple Silicon hardware (M1/M2/M3/M4, etc.)."
        )


class MenuBarApp(rumps.App):
    """Simple macOS status bar app with a single greeting button."""

    def __init__(
        self,
        enable_alerts: bool = True,
        app_support_dir: Optional[str] = None,
        server_enabled: bool = True,
        server_host: str = "127.0.0.1",
        server_port: Optional[int] = None,
        textual_target: str = "latentscore.textual_app:LatentScoreApp",
        server_ready_timeout: float = 3.0,
        server_ready_interval: float = 0.1,
        window_title: str = "LatentScore",
        window_width: int = 1000,
        window_height: int = 700,
        window_resizable: bool = False,
        window_frameless: bool = False,
        window_easy_drag: bool = True,
        initialize: bool = True,
    ) -> None:
        self.enable_alerts = enable_alerts
        self.server_enabled = server_enabled
        self.server_host = server_host
        self._server_port = server_port
        self.textual_target = textual_target
        self.server_ready_timeout = 0.0 if not initialize else server_ready_timeout
        self.server_ready_interval = server_ready_interval
        self.window_title = window_title
        self.window_width = window_width
        self.window_height = window_height
        self.window_resizable = window_resizable
        self.window_frameless = window_frameless
        self.window_easy_drag = window_easy_drag
        self._app_support_dir = app_support_dir
        self._server_proc: subprocess.Popen[bytes] | None = None
        self._server_log_file: IO[bytes] | None = None
        self._webview_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_log_file: IO[bytes] | None = None
        self._diagnostics_webview_proc: subprocess.Popen[bytes] | None = None
        self._diagnostics_port: Optional[int] = None
        self._quit_watch_timer: Optional[rumps.Timer] = None
        if not initialize:
            self.hi_item = SimpleNamespace(title=GREETING_TITLE)
            self.open_item = SimpleNamespace(title=OPEN_UI_TITLE)
            self.logs_item = SimpleNamespace(title=OPEN_LOGS_TITLE)
            self.diagnostics_item = SimpleNamespace(title=SEE_DIAGNOSTICS_TITLE)
            self.quit_item = SimpleNamespace(title=QUIT_TITLE)
            return

        if app_support_dir:
            base = Path(app_support_dir)
            base.mkdir(parents=True, exist_ok=True)

            def _application_support(_name: str) -> str:
                base.mkdir(parents=True, exist_ok=True)
                return str(base)

            assert hasattr(rumps, "application_support")
            setattr(rumps, "application_support", _application_support)
            assert hasattr(rumps_utils, "application_support")
            setattr(rumps_utils, "application_support", _application_support)

        super().__init__("LatentScore", quit_button=None)  # type: ignore[misc]
        self._register_signal_handlers()
        atexit.register(self._stop_server)
        atexit.register(self._stop_webview)
        atexit.register(self._stop_diagnostics_server)
        atexit.register(self._stop_diagnostics_webview)
        self.hi_item = rumps.MenuItem(GREETING_TITLE, callback=self._on_hi_clicked)
        self.open_item = rumps.MenuItem(OPEN_UI_TITLE, callback=self._on_open_clicked)
        self.logs_item = rumps.MenuItem(OPEN_LOGS_TITLE, callback=self._on_open_logs_clicked)
        self.diagnostics_item = rumps.MenuItem(
            SEE_DIAGNOSTICS_TITLE, callback=self._on_diagnostics_clicked
        )
        self.quit_item = rumps.MenuItem(QUIT_TITLE, callback=self._on_quit_clicked)
        self.menu = [
            self.open_item,
            self.logs_item,
            self.diagnostics_item,
            self.hi_item,
            self.quit_item,
        ]
        self._start_quit_watch()
        if self.server_enabled:
            self._ensure_server()

    def _on_hi_clicked(self, _sender: object) -> str:
        if self.enable_alerts:
            self._activate_app()
            self._alert("latentscore", GREETING_MESSAGE)
        return GREETING_MESSAGE

    def _on_open_clicked(self, _sender: object) -> str:
        if not self._ensure_server():
            return ""
        url = self._current_url()
        if not self._open_webview(url):
            webbrowser.open(url)
        return url

    def _on_open_logs_clicked(self, _sender: object) -> str:
        log_dir = self._log_dir()
        env_hint = f"(override with ${LOG_DIR_ENV})"
        if log_dir.exists():
            subprocess.Popen(["open", str(log_dir)])
        elif self.enable_alerts:
            self._alert(
                "latentscore",
                f"Logs directory not found yet: {log_dir}\n{env_hint}",
            )
        return str(log_dir)

    def _on_diagnostics_clicked(self, _sender: object) -> str:
        if not self._ensure_diagnostics_server():
            if self.enable_alerts:
                self._alert(
                    "latentscore",
                    "Diagnostics viewer unavailable. Install textual-serve to open logs.",
                )
            return ""
        url = self._diagnostics_url()
        if not self._open_diagnostics_webview(url):
            webbrowser.open(url)
        return url

    def _on_quit_clicked(self, _sender: object) -> None:
        self._shutdown()
        self._quit_application()

    def _current_url(self) -> str:
        port = self._server_port or 0
        return f"http://{self.server_host}:{port}"

    def _ensure_server(self) -> bool:
        if not self.server_enabled:
            return False
        if self._server_proc and self._server_proc.poll() is None:
            return self._wait_for_server_ready()
        if not self._start_server():
            return False
        if self._wait_for_server_ready():
            return True
        self._stop_server()
        if self.enable_alerts:
            self._alert(
                "latentscore",
                "LatentScore UI failed to start. Try again or run it from the terminal for details.",
            )
        return False

    def _start_server(self) -> bool:
        port = self._server_port or self._find_free_port()
        self._server_port = port
        cmd = self._server_command(port)
        if cmd is None:
            if self.enable_alerts:
                self._alert(
                    "latentscore",
                    "Textual web server is missing. Install textual-serve and try again.",
                )
            return False
        log_path = self._server_log_path()
        log_path.parent.mkdir(parents=True, exist_ok=True)
        log_file = open(log_path, "ab")
        self._server_proc = subprocess.Popen(
            cmd,
            stdout=log_file,
            stderr=subprocess.STDOUT,
            env=self._server_env(),
            start_new_session=True,
        )
        self._server_log_file = log_file
        return True

    def _server_command(self, port: int) -> list[str] | None:
        if importlib.util.find_spec("textual_serve") is None:
            return None
        return [
            sys.executable,
            "-m",
            "latentscore.textual_serve_runner",
            "--host",
            self.server_host,
            "--port",
            str(port),
            "--app",
            self.textual_target,
        ]

    def _server_log_path(self) -> Path:
        return log_path("menubar-server.log", self._app_support_dir)

    def _log_dir(self) -> Path:
        if self._app_support_dir:
            return Path(self._app_support_dir)
        return default_log_dir()

    def _server_env(self) -> dict[str, str]:
        env = os.environ.copy()
        if LOG_DIR_ENV not in env:
            env[LOG_DIR_ENV] = str(self._log_dir())
        source_root = str(Path(__file__).resolve().parents[1])
        pythonpath = env.get("PYTHONPATH", "")
        paths = [path for path in pythonpath.split(os.pathsep) if path]
        if source_root not in paths:
            paths.insert(0, source_root)
        env["PYTHONPATH"] = os.pathsep.join(paths)
        return env

    def _open_webview(self, url: str) -> bool:
        if self._webview_proc and self._webview_proc.poll() is None:
            self._bring_to_front(self.window_title)
            return True
        cmd = self._webview_command(url)
        if cmd is None:
            if self.enable_alerts:
                self._alert(
                    "latentscore",
                    "Native window requires pywebview. Install it to avoid opening a browser.",
                )
            return False
        self._webview_proc = subprocess.Popen(cmd, env=self._server_env(), start_new_session=True)
        self._bring_to_front(self.window_title)
        return True

    def _webview_command(self, url: str) -> list[str] | None:
        if importlib.util.find_spec("webview") is None:
            return None
        cmd = [
            sys.executable,
            "-m",
            "latentscore.webview_app",
            "--url",
            url,
            "--title",
            self.window_title,
            "--width",
            str(self.window_width),
            "--height",
            str(self.window_height),
        ]
        cmd.append("--resizable" if self.window_resizable else "--no-resizable")
        cmd.append("--frameless" if self.window_frameless else "--no-frameless")
        cmd.append("--easy-drag" if self.window_easy_drag else "--no-easy-drag")
        return cmd

    def _wait_for_server_ready(self) -> bool:
        if self._server_port is None:
            return False
        if self.server_ready_timeout <= 0:
            return True
        deadline = time.monotonic() + self.server_ready_timeout
        while time.monotonic() < deadline:
            if self._server_proc and self._server_proc.poll() is not None:
                return False
            try:
                with socket.create_connection(
                    (self.server_host, self._server_port),
                    timeout=min(self.server_ready_interval, 0.5),
                ):
                    return True
            except OSError:
                time.sleep(self.server_ready_interval)
        return False

    def _diagnostics_url(self) -> str:
        port = self._diagnostics_port or 0
        return f"http://{self.server_host}:{port}"

    def _ensure_diagnostics_server(self) -> bool:
        if self._diagnostics_proc and self._diagnostics_proc.poll() is None:
            return self._wait_for_diagnostics_ready()
        if not self._start_diagnostics_server():
            return False
        if self._wait_for_diagnostics_ready():
            return True
        self._stop_diagnostics_server()
        return False

    def _wait_for_diagnostics_ready(self) -> bool:
        if self._diagnostics_port is None:
            return False
        if self.server_ready_timeout <= 0:
            return True
        deadline = time.monotonic() + self.server_ready_timeout
        while time.monotonic() < deadline:
            if self._diagnostics_proc and self._diagnostics_proc.poll() is not None:
                return False
            try:
                with socket.create_connection(
                    (self.server_host, self._diagnostics_port),
                    timeout=min(self.server_ready_interval, 0.5),
                ):
                    return True
            except OSError:
                time.sleep(self.server_ready_interval)
        return False

    def _start_diagnostics_server(self) -> bool:
        port = self._diagnostics_port or self._find_free_port()
        self._diagnostics_port = port
        cmd = self._diagnostics_server_command(port)
        if cmd is None:
            return False
        log_path = self._diagnostics_log_path()
        log_path.parent.mkdir(parents=True, exist_ok=True)
        log_file = open(log_path, "ab")
        self._diagnostics_proc = subprocess.Popen(
            cmd,
            stdout=log_file,
            stderr=subprocess.STDOUT,
            env=self._server_env(),
            start_new_session=True,
        )
        self._diagnostics_log_file = log_file
        return True

    def _diagnostics_server_command(self, port: int) -> list[str] | None:
        if importlib.util.find_spec("textual_serve") is None:
            return None
        return [
            sys.executable,
            "-m",
            "latentscore.textual_serve_runner",
            "--host",
            self.server_host,
            "--port",
            str(port),
            "--app",
            "latentscore.diagnostics_tui:build_app",
        ]

    def _diagnostics_log_path(self) -> Path:
        return log_path("diagnostics-server.log", self._app_support_dir)

    def _open_diagnostics_webview(self, url: str) -> bool:
        if self._diagnostics_webview_proc and self._diagnostics_webview_proc.poll() is None:
            self._bring_to_front("LatentScore Diagnostics")
            return True
        cmd = self._diagnostics_webview_command(url)
        if cmd is None:
            return False
        self._diagnostics_webview_proc = subprocess.Popen(
            cmd, env=self._server_env(), start_new_session=True
        )
        self._bring_to_front("LatentScore Diagnostics")
        return True

    def _diagnostics_webview_command(self, url: str) -> list[str] | None:
        if importlib.util.find_spec("webview") is None:
            return None
        cmd = [
            sys.executable,
            "-m",
            "latentscore.webview_app",
            "--url",
            url,
            "--title",
            "LatentScore Diagnostics",
            "--width",
            str(self.window_width),
            "--height",
            str(self.window_height),
        ]
        cmd.append("--resizable" if self.window_resizable else "--no-resizable")
        cmd.append("--frameless" if self.window_frameless else "--no-frameless")
        cmd.append("--no-easy-drag")
        return cmd

    def _find_free_port(self) -> int:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.bind((self.server_host, 0))
            return sock.getsockname()[1]

    def _stop_server(self) -> None:
        if self._server_proc and self._server_proc.poll() is None:
            self._terminate_process_group(self._server_proc)
        if self._server_log_file:
            self._server_log_file.close()
            self._server_log_file = None

    def _stop_webview(self) -> None:
        if self._webview_proc and self._webview_proc.poll() is None:
            self._terminate_process_group(self._webview_proc)

    def _stop_diagnostics_server(self) -> None:
        if self._diagnostics_proc and self._diagnostics_proc.poll() is None:
            self._terminate_process_group(self._diagnostics_proc)
        if self._diagnostics_log_file:
            self._diagnostics_log_file.close()
            self._diagnostics_log_file = None

    def _stop_diagnostics_webview(self) -> None:
        if self._diagnostics_webview_proc and self._diagnostics_webview_proc.poll() is None:
            self._terminate_process_group(self._diagnostics_webview_proc)

    def _terminate_process_group(self, proc: subprocess.Popen[bytes]) -> None:
        if os.name == "nt" or not hasattr(os, "killpg"):
            proc.terminate()
            try:
                proc.wait(timeout=3)
            except subprocess.TimeoutExpired:
                proc.kill()
            return
        try:
            os.killpg(proc.pid, signal.SIGTERM)
        except ProcessLookupError:
            return
        try:
            proc.wait(timeout=3)
        except subprocess.TimeoutExpired:
            try:
                os.killpg(proc.pid, signal.SIGKILL)
            except ProcessLookupError:
                return

    def _register_signal_handlers(self) -> None:
        for sig in (signal.SIGTERM, signal.SIGINT):
            signal.signal(sig, self._handle_signal)

    def _handle_signal(self, _signum: int, _frame: object | None) -> None:
        self._shutdown()
        raise SystemExit(0)

    def _shutdown(self) -> None:
        self._stop_diagnostics_webview()
        self._stop_diagnostics_server()
        self._stop_webview()
        self._stop_server()

    def _start_quit_watch(self) -> None:
        self._quit_watch_timer = rumps.Timer(self._poll_quit_signal, 0.25)
        self._quit_watch_timer.start()

    def _poll_quit_signal(self, _timer: rumps.Timer) -> None:
        ui_signal = log_path(QUIT_SIGNAL_FILENAME, self._app_support_dir)
        if ui_signal.exists():
            try:
                ui_signal.unlink()
            except OSError:
                return
            self._stop_webview()
            self._stop_server()
            return
        diagnostics_signal = log_path(DIAGNOSTICS_QUIT_SIGNAL_FILENAME, self._app_support_dir)
        if not diagnostics_signal.exists():
            return
        try:
            diagnostics_signal.unlink()
        except OSError:
            return
        self._stop_diagnostics_webview()
        self._stop_diagnostics_server()

    def _alert(self, title: str, message: str) -> None:
        alert = getattr(rumps, "alert", None)
        assert callable(alert)
        alert(title, message)

    def _quit_application(self) -> None:
        quit_application = getattr(rumps, "quit_application", None)
        assert callable(quit_application)
        quit_application()

    def _activate_app(self) -> None:
        """Bring the current application to the front using NSApplication."""
        if platform.system() != "Darwin":
            return
        # pyright: ignore[reportUnknownMemberType,reportUnknownVariableType]
        app: Any = NSApplication.sharedApplication()  # type: ignore[reportUnknownMemberType]
        app.activateIgnoringOtherApps_(True)  # type: ignore[reportUnknownMemberType]
        if hasattr(app, "unhide_"):
            app.unhide_(None)  # type: ignore[reportUnknownMemberType]
        if hasattr(app, "arrangeInFront_"):
            app.arrangeInFront_(None)  # type: ignore[reportUnknownMemberType]
        running_app = NSRunningApplication.currentApplication()  # type: ignore[reportUnknownMemberType]
        if running_app is None:
            return
        options = NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows
        running_app.activateWithOptions_(options)  # type: ignore[reportUnknownMemberType]

    def _bring_to_front(self, title: str) -> None:
        if platform.system() != "Darwin":
            return
        safe_title = title.replace('"', '\\"')
        script = f'tell application "{safe_title}" to activate'
        subprocess.run(["osascript", "-e", script], capture_output=True, text=True)


def run_menu_bar() -> None:
    require_apple_silicon()
    MenuBarApp().run()  # type: ignore[call-arg]


if __name__ == "__main__":
    run_menu_bar()
</file>

<file path="tests/test_menubar.py">
import platform
import sys

import pytest

from latentscore.menubar import (
    GREETING_MESSAGE,
    GREETING_TITLE,
    OPEN_LOGS_TITLE,
    OPEN_UI_TITLE,
    QUIT_TITLE,
    SEE_DIAGNOSTICS_TITLE,
    MenuBarApp,
    require_apple_silicon,
)


def test_greeting_message_constant() -> None:
    assert GREETING_MESSAGE == "Hi there!"
    assert GREETING_TITLE == "Say hi"
    assert OPEN_UI_TITLE == "Open LatentScore"
    assert OPEN_LOGS_TITLE == "Open Logs Folder"
    assert SEE_DIAGNOSTICS_TITLE == "See Diagnostics"
    assert QUIT_TITLE == "Quit"


def test_require_apple_silicon() -> None:
    """Test that the function enforces macOS + Apple Silicon hardware."""
    from latentscore.menubar import _is_apple_silicon_hardware

    is_macos = platform.system() == "Darwin"
    is_apple_silicon = is_macos and _is_apple_silicon_hardware()

    if is_apple_silicon:
        require_apple_silicon()  # Should pass
    else:
        with pytest.raises(RuntimeError):
            require_apple_silicon()


def test_menu_bar_app_sets_menu_item_title(tmp_path) -> None:
    app = MenuBarApp(enable_alerts=False, app_support_dir=str(tmp_path), initialize=False)
    assert app.hi_item.title == GREETING_TITLE
    assert app._on_hi_clicked(None) == GREETING_MESSAGE
    assert app.open_item.title == OPEN_UI_TITLE
    assert app.logs_item.title == OPEN_LOGS_TITLE
    assert app.diagnostics_item.title == SEE_DIAGNOSTICS_TITLE
    assert app.quit_item.title == QUIT_TITLE


def test_on_open_starts_server_and_opens_browser(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False, server_ready_timeout=0.0)
    started = {}

    def fake_start_server() -> bool:
        started["ok"] = True
        app._server_port = 4242
        return True

    opened = {}
    app._start_server = fake_start_server  # type: ignore[assignment]

    def fake_open_webview(_self, url: str) -> bool:
        opened["url"] = url
        return True

    monkeypatch.setattr("latentscore.menubar.MenuBarApp._open_webview", fake_open_webview)

    url = app._on_open_clicked(None)
    assert started["ok"] is True
    assert opened["url"] == "http://127.0.0.1:4242"
    assert url == opened["url"]


def test_server_disabled_skips_start(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, server_enabled=False, initialize=False)

    def fail() -> None:
        raise AssertionError("server should not start when disabled")

    app._start_server = fail  # type: ignore[assignment]
    app._ensure_server()


def test_server_command_uses_runner(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)

    monkeypatch.setattr("latentscore.menubar.importlib.util.find_spec", lambda name: object())
    cmd = app._server_command(4242)
    assert cmd is not None
    assert cmd[:3] == [sys.executable, "-m", "latentscore.textual_serve_runner"]
    assert "--app" in cmd


def test_webview_command_includes_window_args(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)

    monkeypatch.setattr("latentscore.menubar.importlib.util.find_spec", lambda name: object())
    cmd = app._webview_command("http://127.0.0.1:4242")
    assert cmd is not None
    assert cmd[:3] == [sys.executable, "-m", "latentscore.webview_app"]
    assert "--url" in cmd
    assert "--title" in cmd
    assert "--no-frameless" in cmd
    assert "--easy-drag" in cmd


def test_quit_callback_invokes_shutdown(monkeypatch) -> None:
    app = MenuBarApp(enable_alerts=False, initialize=False)
    called = {}

    def fake_shutdown() -> None:
        called["shutdown"] = True

    def fake_quit_application() -> None:
        called["quit"] = True

    app._shutdown = fake_shutdown  # type: ignore[assignment]
    monkeypatch.setattr("latentscore.menubar.rumps.quit_application", fake_quit_application)

    app._on_quit_clicked(None)
    assert called == {"shutdown": True, "quit": True}
</file>

</files>
